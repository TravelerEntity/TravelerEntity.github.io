<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java 基础的重要知识点</title>
    <link href="/2023/Java-%E5%9F%BA%E7%A1%80%E7%9A%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2023/Java-%E5%9F%BA%E7%A1%80%E7%9A%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>Java 基础的重要知识</p><span id="more"></span><h1 id="Java-的变量是值传递还是引用传递？"><a href="#Java-的变量是值传递还是引用传递？" class="headerlink" title="Java 的变量是值传递还是引用传递？"></a>Java 的变量是值传递还是引用传递？</h1><p>我记得在最开始学习 Java 的时候，关于变量传参的方式是这样定义的： </p><blockquote><p>对于基本数据类型 (int, double, long, float) Java 是值传递，而对于引用数据类型 (Array, String, List) Java 是引用传递，也就是直接传递变量地址。</p></blockquote><h2 id="值传递的例子"><a href="#值传递的例子" class="headerlink" title="值传递的例子"></a>值传递的例子</h2><p>不过，最近看了<a href="https://javaguide.cn/java/basis/why-there-only-value-passing-in-java.html">一篇文章</a>发现事实并非如此。<strong>先说结论：在 Java 中，所有变量都是值传递，无论是基本类型还是引用类型都是如此。</strong> 那么现在问题来了，既然 Java 中引用类型也是值传递，为什么方法内的操作变量会影响到外部的变量呢？看下方这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     <span class="hljs-type">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br>     System.out.println(<span class="hljs-string">&quot;before change arr[0] = &quot;</span>+ arr[<span class="hljs-number">0</span>]);<br>     change(arr);<br>     System.out.println(<span class="hljs-string">&quot;after change arr[0] = &quot;</span>+ arr[<span class="hljs-number">0</span>]);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br>     <span class="hljs-comment">// 将数组的第一个元素变为0</span><br>     array[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs terminal">before change arr[0] = 1<br>after change arr[0] = 0<br></code></pre></td></tr></table></figure><p>可以看到，我们在 <code>change</code> 方法中对 <code>array</code> 进行修改后，函数外也看到了效果。为什么值传递呈现了引用传递的效果呢？关键点在于，Java 中传递的是<strong>变量地址值的副本</strong>。引用类型的参数在传递时，会将引用的地址值，复制一份传递到方法内部。前面 <code>change</code> 函数接收的实际上是 <code>arr</code> 地址的副本。在 <code>change</code> 方法内部，<code>arr</code> 和 <code>array</code> 两个变量都指向了同一个地址。所以，方法 <code>change</code> 对数组的修改会同步到方法外部。</p><h2 id="引用传递的例子"><a href="#引用传递的例子" class="headerlink" title="引用传递的例子"></a>引用传递的例子</h2><p>我们再看一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>   <span class="hljs-comment">// 省略构造函数、Getter&amp;Setter方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">xiaoZhang</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;小张1&quot;</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">xiaoLi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;小李2&quot;</span>);<br>        swap(xiaoZhang, xiaoLi);<br>        System.out.println(<span class="hljs-string">&quot;xiaoZhang:&quot;</span> + xiaoZhang.getName());<br>        System.out.println(<span class="hljs-string">&quot;xiaoLi:&quot;</span> + xiaoLi.getName());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(Person person1, Person person2)</span> &#123;<br>        <span class="hljs-comment">// swap 前 xz = p1，xl = p2</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> person1;<br>        person1 = person2;<br>        person2 = temp;<br><br>        <span class="hljs-comment">// swap 后，xz = xl = p2 ，xl = xz = p1</span><br>        System.out.println(<span class="hljs-string">&quot;person1:&quot;</span> + person1.getName());<br>        System.out.println(<span class="hljs-string">&quot;person2:&quot;</span> + person2.getName());<br><br>        person1.setName(<span class="hljs-string">&quot;person1 xl &quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>最终输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs terminal">person1:xiaoLi = 小李2<br>person2:xiaoZhang = 小张1<br>xiaoZhang:xiaoZhang = 小张1<br>xiaoLi:person1 xl <br></code></pre></td></tr></table></figure><p>这个例子中，xiaoZhang &#x3D; 小张1，xiaoLi &#x3D; 小李2，我们在 swap 函数中交换了它们两个然后并打印。从输出结果中可以看出，在函数体内，它们两个确实是已经交换。但在函数体外部再打印，它们的值却没有任何变化。这也就印证了， Java 中引用变量传递的是地址的副本，而不是地址本身这个理论了。<br><img src="/images/2023/before_swap.png" alt="swap 前"><br>我们在方法中交换两个变量，也只是交换的两个副本变量指向的地址，函数外部变量指向的地址的没有任何影响。<br><img src="/images/2023/after_swap.png" alt="swap 后"></p><p>这种方式的好处在于，方法内部的操作不会莫名其妙地对外部造成影响，减少意想不到的结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Java 中，变量的传递都是值传递，不存在引用传递。</li><li>对于引用变量，在传递时，是先复制的引用变量的地址，然后再传递。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工地，黄昏，晚风，晨光。</title>
    <link href="/2022/07/%E5%B7%A5%E5%9C%B0%EF%BC%8C%E9%BB%84%E6%98%8F%EF%BC%8C%E6%99%9A%E9%A3%8E%EF%BC%8C%E6%99%A8%E5%85%89%E3%80%82/"/>
    <url>/2022/07/%E5%B7%A5%E5%9C%B0%EF%BC%8C%E9%BB%84%E6%98%8F%EF%BC%8C%E6%99%9A%E9%A3%8E%EF%BC%8C%E6%99%A8%E5%85%89%E3%80%82/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在一次失败的暑假工之后，我来到建筑工地开始了兼职。</p></blockquote><span id="more"></span><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>在某一个兼职公众号上看到说工地需要打扫清洁卫生。<strong>时薪22</strong>，从20点到第二天6点，一共十小时。我想了想，打扫个清洁而已，应该不会太累，虽然是夜班，但他给得还算不错。随后我就加上了中介的微信准备开始工作。在简单的交谈后，我得知明天的班次时间有变，<strong>从15点开始，下班时间还不确定</strong>。我想就是加班干，也不至于太离谱吧（然而事实给了我一个狠狠的大逼兜）。第二天15点左右，我和他们一起到达了建筑工地。</p><p><img src="/images/2022S3/myEquip.jpg" alt="随身装备"></p><h2 id="工地"><a href="#工地" class="headerlink" title="工地"></a>工地</h2><p>穿过两侧充满黑色泥水的大门，经过满是泥浆的道路，再爬上一层又一层用脚手架打出来的简易楼梯，我终于到达了最终目的地。在见到场景前，台锯产生的噪音已经吸引了我的全部注意力，紧接着就是木屑的味道，然后才是满眼的脚手架、木材、钢材，当然还有正在劳动的工人。</p><h2 id="黄昏，晚风"><a href="#黄昏，晚风" class="headerlink" title="黄昏，晚风"></a>黄昏，晚风</h2><p>我的工作主要就是负责给大佬递东西，帮他们找工具、材料之类的。不是特别困难，只是需要拿着东西在一片片的脚手架中穿梭，偶尔撞到头，或者被从头顶上掉下来的工具吓到。就这样熬到了19点，干饭时间到。</p><p><img src="/images/2022S3/dinner.jpg" alt="尖叫豆干猪头🐷肉"></p><p>也许是因为体力劳动的缘故，这顿饭我吃得真是那叫一个香。现在想起都想再干一碗。</p><p>等到晚宴用毕，已是20点了，真正的上班开始了。这时我问旁边的一个小工友，他说是24点下班，这给了我不小的动力和希望。后面，在去那材料的时候，和几个摸鱼的工友交谈得知，我们今天可能得加班到明天6点下班，当时就…….😶。这是真的么，从15-06，中间隔了十五个小时？这是我能做的活儿吗？</p><p><img src="/images/2022S3/setOnTheScaffold.jpg" alt="在脚手架上"></p><p>接下来就是非常非常非常无聊的熬时间了，我的脑子全是各种奇怪的想法：脚手架是不是要倒了？是不是在地震？我会不会突然被头顶上掉下来的东西砸成制片？我会不会突然失足从楼顶掉下去摔个稀巴烂？</p><p>只有偶尔吹来的清凉的晚风将我的思绪从混沌中拉扯出来，让我清醒一会儿。想起来，这种感觉和在流水线上班时一模一样。回来了，一切都回来了😂。</p><p>时间就这样缓慢流过，24点时我们短暂休息吃了点面包。然后就是直接干到了快五点。好像是活儿做完了，但是工头说喊我们等到六点再下班，工人们自然是觉得能免费送一个工时自然是再好不过，欣然接受了。毕竟大工一小时50呢。我呢？我这人不知道走了几层中介，我只有22一个小时。隔壁组的中介是30一个小时，然后和我一组的一个小工没走中介，35一小时😂。</p><p><img src="/images/2022S3/dawnOfTheSite.jpg" alt="黎明时分的工地"></p><p>用仅存的一点电量拍完这种照片后，我的手机就罢工了。然后陪伴我的就是热情的蚊子了。</p><h2 id="晨光"><a href="#晨光" class="headerlink" title="晨光"></a>晨光</h2><p>在蚊子们的陪伴下，终于迎来了下班，离开工地的时候，我的内心才有一种出了一口气的感觉。终于结束了。上次的流水线经历激励了我4年的学习，从中专到单招、高考和最后的专升本。那么这次工地的经历能否激励我读个研呢？</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂谈</tag>
      
      <tag>我的灿烂人生</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考试开始！——2022年中总结</title>
    <link href="/2022/07/%E5%B1%95%E6%9C%9B%E6%9C%AA%E6%9D%A5%E5%90%A7%EF%BC%81%E2%80%94%E2%80%942022%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/"/>
    <url>/2022/07/%E5%B1%95%E6%9C%9B%E6%9C%AA%E6%9D%A5%E5%90%A7%EF%BC%81%E2%80%94%E2%80%942022%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>像是一场看得见终点的苦修，你知道更强大的自己更加强大的自己就在那里，这几年的马不停蹄，终究对得起。</p></blockquote><span id="more"></span><p>如果按照原计划，在放假后我首先要做的应该就是去找工作，完成我最后一学期的课题——实习。不过好在我参加了学校的一个开发竞赛，得以在最后一个学期重返学校进行竞赛培训。这就使我得以在假期专注学习，而不至于被工作搞得焦头烂额。</p><h2 id="寒假"><a href="#寒假" class="headerlink" title="寒假"></a>寒假</h2><p>本以为这次的学习情况可能会和以往的假期差不多。放假前设计的各种学习计划只是空头支票。不过还好，这次是我自己低估我自己了，在即将到来的考试压迫下，这次假期的学习效率不可谓不高。</p><p>那么此时我就有两个任务，竞赛培训和专升本考试。竞赛使用的框架我也是零基础，需要重新学习，等于我要双线作战。更要命的是，比赛时间恰好也是在四月中下旬。</p><p>在这种情况下，寒假第二天我就开始了复习进度。</p><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>鉴于我有良好的自我认识能力（自知自明），我的学习目标主要就是高数这一科，英语和计算机都可以放到开学之后再进行。然后就是开始进行复习了。学习资源的话，在很早之前就被专升本群里的同学安利杰哥专升本，所以就直接跟着杰哥的课程走。</p><p>前期学习的进度是很缓慢的，而且我还要关注竞赛的学习。竞赛的任务是每两天完成一道题。前面几道还很简单，几分钟一道。后面的越来越离谱，第一遍做的时候直接用了十几个小时。</p><p>整个假期的学习就这样有条不紊的进行。</p><p><img src="/images/2022S3/chartOfLearning.jpg" alt="一周学习"></p><h2 id="春节"><a href="#春节" class="headerlink" title="春节"></a>春节</h2><p>今天过年我们全家去舅舅那边过。于是在二十九的时候，我们出发前往成都。简而言之，春节期间没什么学习进度，都是在家里玩儿，有时候大家会一起出去转转路之类的。然后留给我的就只有冷了🥶。</p><h2 id="学校"><a href="#学校" class="headerlink" title="学校"></a>学校</h2><p>春节过后回到家照常学习了一周后，开学时间就到了。</p><p>通过门禁进入学校，走在足球场边的人行道上，再穿过提着大包小包、热闹的同学们，最后走进宿舍楼，站在熟悉的门牌号下。空气中很安静，本以为当时关上这扇门之后就再也不会回来了，没想到这么快又见面了。打开门锁进去之后，一切的陈列依旧。只是床板上都是空空如也。有两张床上放满了陌生的东西。我想应该是新室友的吧。</p><p>在短暂的休整，收拾宿舍之后。我的学习任务也就继续开展。</p><h3 id="在新学期学习"><a href="#在新学期学习" class="headerlink" title="在新学期学习"></a>在新学期学习</h3><p>与家里不同的是，在学校学习老师会时不时来监工😂，看我们在没在学习。不过好在老师很善解人意，在完成了当天的竞赛任务后，就可以自由安排学习内容。所以情况就变成了，上午学习高数，下午分成两段，一段还是高数，另一段则是专业学习。至于晚上嘛，在新室友的陪同下，晚上则被我安排成了娱乐活动——打乒乓球。</p><p><img src="/images/2022S3/desktop.jpg" alt="桌面"></p><p>此后的学习情况就基本按照这个模式进行。</p><p><img src="/images/2022S3/officeOfLearning.jpg" alt="学习的办公室，刚好可以眺望到乒乓球场"></p><p>高数的第一轮学习在三月上旬旬左右结束。紧接着就是刷题了。和杰哥专升本配套的周老师一千题刚好可以拿来复习。由于基础篇太简单，我直接跳到了进阶篇。做题比学习痛苦多了，说实话。特别是进阶篇的。一道二重积分，来回算我能算半个钟，最后答案还是错的！还好我坚持下来了，而且在后面，对于那些特难题我也很明智的排除出去。我赌他考试不会搞这么难。</p><p>第一轮刷题直到四月上旬才进行完。虽然高数解决完了一遍， 但是线性代数我还根本没有起步。所以接下来的安排就是线性代数和复习英语计算机。</p><p>四月上旬的某一天，老师告诉我们说因为疫情，竞赛取消。刚好那是我正为学习时间不够而发愁呢。所以在这个阶段完成了线性代数的学习和英语，以及计算机的复习。</p><p>四月中旬，最后十天的时间用来刷卷子，刷之前的错题。库课的高数卷分两种，一种的模拟卷，一种真题卷。它们的难度完全是两个极端，模拟卷我的均分在70多，真题卷直接及不了格。所以做这两种卷子就很折磨人。做模拟卷的时候，我就觉得太简单了，考试肯定不会这么简单；做真题卷的时候，内心就直接是<em>已经考不上了，放下笔吧</em>。英语和计算机我选择的直接刷卷子。英语的语法也是很折磨人，今年还取消了我的强项听力。改成了三十道语法题，这可要了我的老命了。我的正确率在三分之一左右，即使后面恶补了几下语法，也才勉强把正确率提到二分之一。阅读的正确率还好，正确率在八成以上。计算机的话，八十左右。我已经没时间再去背那些东西了🥲。</p><h3 id="考试开始"><a href="#考试开始" class="headerlink" title="考试开始"></a>考试开始</h3><p>拿到数学卷子的一瞬间，首先要做的就是翻到后面的大题。看完以后，我心里乐开了花，就这？</p><p>交卷以后，对完答案才发现，我光顾大题，选择和填空差不多各丢了一半儿的分🥲。</p><p>考完高数后，我心里的一块石头终于落地了，英语和计算机则是普普通通的完成。</p><h3 id="考试结束"><a href="#考试结束" class="headerlink" title="考试结束"></a>考试结束</h3><p>结束之后就是简单的…无聊了。突然多出来好多的空闲时间。天天打球也不现实。还好我提前就知道会这样，所以早在专升本复习的时候，我就把六级的名给报了。考试驱动学习嘛。在疯玩儿了几天后，我就继续投入了六级的学习中。</p><h3 id="六级"><a href="#六级" class="headerlink" title="六级"></a>六级</h3><p>此时我还有大概40天时间。</p><p>首先就是得背单词，六级1.8k的核心词，一天80，20天左右就能背完。所以接下来每天上午的三个小时左右的时间就由单词主导啦。下午则是接受考虫各位老师的指导。在这种状态下，我甚至觉得比之前复习专升本还要充实。学习体验比专升本好到不知道哪里去了。白天认认真真地学，晚上认认真真地玩儿，根本不用焦虑，紧张。</p><p>时间很快就到了六级考试的时候。同样，拿到卷子的一瞬间，先翻作文。看到作文题目的一瞬间我心里当时就开心到发抖。这个题目，是最最最简单好些的那种！作文满分100出头，我起码拿个八十这次。然而俗话说的好，佛祖给你打开了一扇窗，也会给你关上一扇门。到了听力阶段，本来均分在160-200左右的听力，这次可能只有120-140左右😭😭😭我真的哭死。</p><p><img src="/images/2022S3/CET6Listening.jpg" alt="一次模考结果的听力部分"></p><h3 id="暑假"><a href="#暑假" class="headerlink" title="暑假"></a>暑假</h3><p><img src="/images/2022S3/flightOnTheSky.jpg" alt="销售公司附近的天空"></p><p>考完试后，就该回家了。回家之后，第二天我就前往了成都开始暑假工之旅。在这之前，我的新室友Louis已经提前出发在成都等我一起进厂了。然而，等我到了之后才发现，因为有过疫情旅居史，厂里不愿意冒风险招收我们。在六月中旬，我们找到了一个销售活路。与其说是找，不如说是骗。无论是工资待遇，还是工作内容，都与面试时不符合。当然这些是在前段时间才了解到，不然我早润了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><input checked="" disabled="" type="checkbox"> 通过专升本</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>杂谈</tag>
      
      <tag>总结</tag>
      
      <tag>我的灿烂人生</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot-尚硅谷</title>
    <link href="/2021/12/springboot-%E5%B0%9A%E7%A1%85%E8%B0%B7/"/>
    <url>/2021/12/springboot-%E5%B0%9A%E7%A1%85%E8%B0%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="一、SpringBoot入门"><a href="#一、SpringBoot入门" class="headerlink" title="一、SpringBoot入门"></a>一、SpringBoot入门</h1><h2 id="1-spring-boot简介"><a href="#1-spring-boot简介" class="headerlink" title="1.spring boot简介"></a>1.spring boot简介</h2><p>spring boot的特点</p><ol><li>boot整合了spring的各种技术栈，比如security、cloud等</li><li>boot简化spring的配置文件</li><li>项目可以以jar包的形式运行，而不是war</li><li>boot是spring框架的框架</li></ol><h2 id="2-微服务"><a href="#2-微服务" class="headerlink" title="2.微服务"></a>2.微服务</h2><p>由martin fowler的一篇文章而来。微服务是一种应用架构风格。传统的单体应用，应用的所有功能都装在一个应用里，当整个项目十分庞大以后，不利于应用的扩展。<strong>所以将整个应用按照功能进行拆分，这就是微服务。</strong> 拆分后，就可以对应用的功能进行单独升级和替换。</p><p><strong>总之，这些调整的一切目的几乎都是为了减少大型项目的复杂度，通过分工合作的方式提高效率。</strong></p><h2 id="3-环境配置"><a href="#3-环境配置" class="headerlink" title="3.环境配置"></a>3.环境配置</h2><h3 id="初始环境"><a href="#初始环境" class="headerlink" title="初始环境"></a>初始环境</h3><ul><li>jdk1.8+</li><li>maven3.3+</li><li>idea2017+</li><li>spring-boot1.5.9Release</li></ul><h3 id="maven配置"><a href="#maven配置" class="headerlink" title="maven配置"></a>maven配置</h3><p>在maven的config文件中加上这段</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="idea配置"><a href="#idea配置" class="headerlink" title="idea配置"></a>idea配置</h3><p>把idea自带的maven替换为我们自己安装的maven，路径为：<code>settings/buildtools/maven</code></p><h2 id="4-spring-boot-hello-world"><a href="#4-spring-boot-hello-world" class="headerlink" title="4. spring-boot hello world"></a>4. spring-boot hello world</h2><p>spring boot的hello world步骤：</p><h4 id="4-1创建maven项目，不使用模板"><a href="#4-1创建maven项目，不使用模板" class="headerlink" title="4.1创建maven项目，不使用模板"></a>4.1创建maven项目，不使用模板</h4><h4 id="4-2添加spring-boot依赖"><a href="#4-2添加spring-boot依赖" class="headerlink" title="4.2添加spring boot依赖"></a>4.2添加spring boot依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里出现了一个问题，一开始给maven配置编译的jkd时一个标签的结束符号忘记打了，所以就导致pom一直爆红。后面查看具体错误报告时才发现问题所在，所以以后要仔细检查错误报告。</p><h4 id="4-3编写代码"><a href="#4-3编写代码" class="headerlink" title="4.3编写代码"></a>4.3编写代码</h4><h5 id="4-3-1创建spring-boot-主类"><a href="#4-3-1创建spring-boot-主类" class="headerlink" title="4.3.1创建spring boot 主类"></a>4.3.1创建spring boot 主类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldMainApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//启动代码</span><br>        SpringApplication.run(HelloWorldMainApplication.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-3-2创建controller类"><a href="#4-3-2创建controller类" class="headerlink" title="4.3.2创建controller类"></a>4.3.2创建controller类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World!-------------We live in a world.&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-运行spring-boot主类，就是HelloWorldMainApplication类"><a href="#4-4-运行spring-boot主类，就是HelloWorldMainApplication类" class="headerlink" title="4.4 运行spring boot主类，就是HelloWorldMainApplication类"></a>4.4 运行spring boot主类，就是HelloWorldMainApplication类</h4><h4 id="4-5-简化部署"><a href="#4-5-简化部署" class="headerlink" title="4.5 简化部署"></a>4.5 简化部署</h4><p>通过把项目打成jar包的形式简化部署的流程，jar包内置tomcat，意味着即使服务器没有tomcat也可以运行项目。</p><p>添加插件的依赖后即可打jar包。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>使用<code>maven package</code>命令进行打包</li><li>打好的包在target中</li><li>使用<code>java -jar</code>运行jar包</li></ol><h2 id="5-Hello-world的细节"><a href="#5-Hello-world的细节" class="headerlink" title="5.Hello world的细节"></a>5.Hello world的细节</h2><p>spring boot为我们简化了很多操作，这正是通过我们一开始导入的两个依赖完成的。</p><h3 id="5-1-boot-starter依赖"><a href="#5-1-boot-starter依赖" class="headerlink" title="5.1 boot-starter依赖"></a>5.1 boot-starter依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>spring boot 的版本中心，里面有常用依赖的版本号。有了它可以少些一部分的版本号。</p><h3 id="5-2-boot-starter-xxx依赖"><a href="#5-2-boot-starter-xxx依赖" class="headerlink" title="5.2 boot-starter-xxx依赖"></a>5.2 boot-starter-xxx依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 集成了spring web开发的常用依赖 --&gt;</span><br></code></pre></td></tr></table></figure><p>springboot 把一个个功能场景拆开，分成starter的形式。我们需要用什么功能就写相应的依赖，一切都会自动进行。除了<code>boot-starter-web</code>，还有比如<code>boot-starter-security</code></p><h3 id="5-3-SpringBootApplication"><a href="#5-3-SpringBootApplication" class="headerlink" title="5.3 @SpringBootApplication"></a>5.3 @SpringBootApplication</h3><p>这个注解里面也是一些额外注解（组合注解），算是为了简化注解的标注，把里面的注解都整合成一个<code>@SpringBootApplication</code>注解。<br>它就代表一个springboot应用。</p><p><code>@EnableAutoConfiguration/@AutoConfigurationPackage</code>用来自动开启包扫描，它会自动扫面启动类下面的包(controller)。</p><p>自动配置注解的<code>@EnableAutoConfiguration</code>目的就是为了给我们的springboot程序导配置文件，导包，开包扫描，它内置了各种组件的注解，都是为了减少我们的操作步骤。</p><p><code>@SpringBootConfiguration</code>，标识这是一个<code>springboot</code>的配置类，里面则是一个<code>@Configuration</code>注解，表示一个spring的注解。</p><h2 id="6-springboot-initializer"><a href="#6-springboot-initializer" class="headerlink" title="6 springboot-initializer"></a>6 springboot-initializer</h2><p>idea中继承了一个initializer可以帮助我们快速构建一个springboot项目。</p><p>构建完成后的项目包括</p><ul><li>启动类</li><li>resource文件夹<ul><li>template静态网页模板（由于内置tomcat，springboot不支持jsp）</li><li>static静态资源文件夹</li></ul></li><li>application.properties：spring的配置文件</li></ul><h1 id="二、yaml语法与配置文件"><a href="#二、yaml语法与配置文件" class="headerlink" title="二、yaml语法与配置文件"></a>二、yaml语法与配置文件</h1><h2 id="1-yaml是什么"><a href="#1-yaml是什么" class="headerlink" title="1.yaml是什么"></a>1.yaml是什么</h2><p>yaml是一种比xml更优秀的用来表示数据的文件类型。对比：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>8081<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br></code></pre></td></tr></table></figure><p>相比之下，xml将大部分字符放在了开始和结束标签上，浪费了相当多的存储空间。yaml不仅更简洁，结构也更清晰。</p><h2 id="2-yaml怎么写"><a href="#2-yaml怎么写" class="headerlink" title="2.yaml怎么写"></a>2.yaml怎么写</h2><ul><li>yaml的语法规则区分大小写</li><li>yaml数据的层级关系通过缩进来区分  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># k: v 对前需要加空格，否则无法识别</span><br><span class="hljs-attr">server:</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">YiAn</span><br><span class="hljs-comment"># yaml中，字符串不需要被单双引号引上，单双引号的使用具有其他意义</span><br><span class="hljs-comment"># 单引号表示忽略特殊字符，原样输出。比如：hello \n world 会被原样输出为：hello \n world</span><br><span class="hljs-comment"># 双引号会转义特殊字符，比如：hello \n world 输出为： hello 换行符 world </span><br></code></pre></td></tr></table></figure></li><li>yaml中特殊数据语法基本不变，通过层级体现  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 对象语法</span><br><span class="hljs-attr">person:</span><br>  <span class="hljs-string">name:zhangsan</span><br>  <span class="hljs-string">gender:man</span><br><span class="hljs-comment">#或者</span><br>&#123;<span class="hljs-string">name:zhangsan</span>,<span class="hljs-string">gender:man</span>&#125;<br><span class="hljs-comment"># 集合语法</span><br><span class="hljs-attr">fruits:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">apple</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">pear</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">buleberry</span><br><span class="hljs-comment">#或者</span><br>[<span class="hljs-string">apple</span>,<span class="hljs-string">pear</span>,<span class="hljs-string">buleberry</span>] <br></code></pre></td></tr></table></figure></li></ul><h2 id="3-获取配置文件的值"><a href="#3-获取配置文件的值" class="headerlink" title="3.获取配置文件的值"></a>3.获取配置文件的值</h2><ol><li>使用bean来获取yaml的值，先写一个实体类 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 标识类为组件，只有组件才能使用容器中的功能，比如下面的注解生效</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-comment">// 表示类为属性配置类，prefix 表示要读取的前缀。</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    Integer age;<br>    Map&lt;String,Object&gt; map;<br>    String[] array;<br>    Dog dog;<br>    <span class="hljs-comment">// getters and setters...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>添加配置文件处理器的依赖 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>编写测试类 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//导包的时候一定要到junit.test的包；而不是jupiter</span><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldMainApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Server person;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(person);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><strong>这种方式也可以直接适用于读取properties文件</strong></li></ol><h2 id="4-Value注解和-ConfigurationProperties注解"><a href="#4-Value注解和-ConfigurationProperties注解" class="headerlink" title="4.@Value注解和@ConfigurationProperties注解"></a>4.@Value注解和@ConfigurationProperties注解</h2><p>@Value注解用于给单个属性注入值，而@ConfigurationProperties用来给整个类的属性注入。</p><p><strong>@Value特性：</strong></p><ul><li>单个注入属性</li><li>语法严格</li><li>支持spring表达式</li><li>不支持jsr303数据校验</li><li>不支持复杂数据（对象类型）封装</li></ul><p><strong>@ConfigurationProperties特性</strong></p><ul><li>给整个bean批量注入属性</li><li>语法松散，比如支持 <code>person.lastName == person.last-name</code></li><li>不支持spring表达式</li><li>支持303数据校验</li><li>支持对象封装</li></ul><h3 id="4-1-Value的补充知识"><a href="#4-1-Value的补充知识" class="headerlink" title="4.1@Value的补充知识"></a>4.1@Value的补充知识</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Value是spring的注释，用于给属性注入值</span><br><span class="hljs-comment">// 直接从配置文件中读取值</span><br><span class="hljs-meta">@Value(&quot;$&#123;person.name&#125;&quot;)</span><span class="hljs-comment">//从配置文件中读取</span><br><span class="hljs-keyword">private</span> String name;<br><br><span class="hljs-comment">// spring表达式，除了读取值还能计算</span><br><span class="hljs-meta">@Value(&quot;#&#123;user.username&#125;&quot;)</span><span class="hljs-comment">//从user类中读取</span><br><span class="hljs-meta">@Value(&quot;#&#123;11 * 11&#125;&quot;)</span><span class="hljs-comment">//计算值 121</span><br><span class="hljs-keyword">private</span> Integer product;<br><br><span class="hljs-comment">// 直接注入值</span><br><span class="hljs-meta">@Value(&quot;&#123;测试值&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String testValue;<br></code></pre></td></tr></table></figure><h2 id="5-PropertySource-amp-ImportResource-amp-Bean三个注解"><a href="#5-PropertySource-amp-ImportResource-amp-Bean三个注解" class="headerlink" title="5.@PropertySource&amp;@ImportResource&amp;@Bean三个注解"></a>5.@PropertySource&amp;@ImportResource&amp;@Bean三个注解</h2><h3 id="5-1-PropertySource注解"><a href="#5-1-PropertySource注解" class="headerlink" title="5.1@PropertySource注解"></a>5.1@PropertySource注解</h3><p>因为一个项目一般需要多个配置文件，所以可以在类上再加上一个@PropertySource注解来指定导入某个配置文件。<strong>它只支持properties文件，不支持yaml文件。</strong></p><h3 id="5-2-Bean注解（Recommand）"><a href="#5-2-Bean注解（Recommand）" class="headerlink" title="5.2@Bean注解（Recommand）"></a>5.2@Bean注解（Recommand）</h3><p>springboot推荐使用@Bean注解进行组件注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAppConfig</span> &#123;<br>    <span class="hljs-comment">// 标注在方法上，方法名就是组件id</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TestConfig <span class="hljs-title function_">testConfig</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 返回组件类</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestConfig</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-ImportResource注解-Deprecated"><a href="#5-3-ImportResource注解-Deprecated" class="headerlink" title="5.3@ImportResource注解(Deprecated)"></a>5.3@ImportResource注解(Deprecated)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用于导入Spring的配置文件让其生效</span><br><span class="hljs-meta">@ImportResource(locations = &#123;&quot;classpath:beans.xml&quot;&#125;)</span><br></code></pre></td></tr></table></figure><h2 id="6-配置文件的占位符"><a href="#6-配置文件的占位符" class="headerlink" title="6.配置文件的占位符"></a>6.配置文件的占位符</h2><p>无论是yaml还是Properties都可以使用占位符。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">car.mode</span> = <span class="hljs-string">AudiA6</span><br><span class="hljs-attr">car.engine</span> = <span class="hljs-string">X-4</span><br><span class="hljs-comment"># 使用随机id</span><br><span class="hljs-attr">car.cid</span> = <span class="hljs-string">$&#123;random.uuid&#125;</span><br><span class="hljs-comment"># 使用随机的int数</span><br><span class="hljs-attr">car.cnum</span> = <span class="hljs-string">$&#123;random.int&#125;</span><br><span class="hljs-comment"># 引用之前的值，冒号之后是默认值</span><br><span class="hljs-attr">car.price</span> = <span class="hljs-string">1230,000RMB$&#123;car.mode:BMW X5&#125;</span><br></code></pre></td></tr></table></figure><h2 id="7-多配置文件的使用"><a href="#7-多配置文件的使用" class="headerlink" title="7. 多配置文件的使用"></a>7. 多配置文件的使用</h2><p>一个项目不止一个配置文件，开发环境一种配置，生产环境一种配置。所以需要学习多配置文件的使用。</p><h3 id="7-1properties多配置文件"><a href="#7-1properties多配置文件" class="headerlink" title="7.1properties多配置文件"></a>7.1properties多配置文件</h3><p>程序主配置文件是<code>application.properties</code>，其它环境的配置文件可以是<code>application-dev.properties</code>，通过短横杠区分不同的配置环境。最后通过<code>spring.profiles.active=dev</code>激活具体的配置文件</p><h3 id="72-yaml多配置文件"><a href="#72-yaml多配置文件" class="headerlink" title="72.yaml多配置文件"></a>72.yaml多配置文件</h3><p>yaml在一个配置文件内就可以区别多种环境</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#主配置</span><br><span class="hljs-comment">#激活开发环境的配置</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8009</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment">#开发环境配置</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8008</span><br>  <span class="hljs-comment">#标识环境名</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment">#生产环境配置</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8010</span><br>  <span class="hljs-comment">#标识环境名</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">product</span><br></code></pre></td></tr></table></figure><p>除了在yaml中的标识激活哪个配置，还可以通过传入启动参数的方选择激活。在idea中配置parameter<code>spring.profiles.active</code>，或者命令行传入<code>spring.profiles.active=dev</code></p><h2 id="8-配置文件优先级"><a href="#8-配置文件优先级" class="headerlink" title="8.配置文件优先级"></a>8.配置文件优先级</h2><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- file是项目路径。项目路径下config下的applicaiton配置文件具有最高优先级 --&gt;</span><br>–file:../config/application.yaml<br><br>–file:../application.yaml<br><br>–classpath:/config/application.yaml<br><br>–classpath:/application.yaml<br></code></pre></td></tr></table></figure><p>高优先级会覆盖低优先级的文件。如果合理使用，高低优先级配置文件还可以实现<strong>互补配置</strong>的效果，<strong>即低优先级补充配置高优先级中没有配置的文件</strong>。</p><p>此外，也可以强制指定外部路径为配置文件，还是通过在启动时添加参数的方式。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">java -jar springboot-project --spring.config.location=D:/application.properties<br></code></pre></td></tr></table></figure><p>不过，即使是在低优先级的yaml文件中指定参数<code>spring.profiles.active=dev</code>或者命令行传入参数<code>spring.profiles.active=dev</code>，都能覆盖掉高优先级文件的配置。</p><h2 id="9-加载外部的配置文件"><a href="#9-加载外部的配置文件" class="headerlink" title="9.加载外部的配置文件"></a>9.加载外部的配置文件</h2><p>项目打好包之后如果想临时更改某些配置参数，可以直接在命令号中传入具体参数名。比如临时修改端口号 <code>java -jar springboot-helloworld.jar --server.port=8290</code>，这种优先级最高。类似<code>!impotant</code>。</p><p>对于打好包的项目，如果参数有很多的话，也可以直接在jar包的同级目录放一个application配置文件。<br><strong>btw，.properties文件总是比.yml文件拥有更高的优先级</strong>，如果同级目录下既有一个properties又有yml，那么前者生效。</p><h2 id="10-自动配置的原理"><a href="#10-自动配置的原理" class="headerlink" title="10.自动配置的原理"></a>10.自动配置的原理</h2><p>springboot帮我们完成了大量的配置工作，我们也可以按照需要手动配置某些值</p><blockquote><p>引用笔记</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ​">1）、SpringBoot启动会加载大量的自动配置类<br><br>​2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；<br><br>​3）、（如果有）我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）<br><br>​4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；<br><br>xxxxAutoConfigurartion：自动配置类；<br><br>给容器中添加组件<br><br>xxxxProperties:封装配置文件中相关属性；<br></code></pre></td></tr></table></figure><h3 id="10-1-Conditional注解"><a href="#10-1-Conditional注解" class="headerlink" title="10.1 @Conditional注解"></a>10.1 @Conditional注解</h3><p>springboot有许多<code>@conditionalOnxxx</code>注解，用于条件成立的情况，使配置内容生效。<br>虽然springboot内置了大量的自动配置类，但并不是全都会生效。我们可以通过在配置文件中添加 <code>debug=on</code> 属性，开启springboot的debug模式，从而查看当前项目有哪些自动配置类生效了。</p><h1 id="三、日志系统"><a href="#三、日志系统" class="headerlink" title="三、日志系统"></a>三、日志系统</h1><p>目前的日志系统类似于JDBC和数据库驱动一样。现有一个日志接口层，然后再有不同的日志接口实现类。SpringBoot使用的日志接口是SLF4J，接口实现是Logback。</p><h3 id="1-日志的使用"><a href="#1-日志的使用" class="headerlink" title="1 日志的使用"></a>1 日志的使用</h3><p>和JDBC类似，使用日志使掉的是接口层的方法，不需要去关心实现层是什么样的方法。实际使用时，调用SEL4J的方法就行，尽管它有多种的实现层。</p><h3 id="2-日志配置文件"><a href="#2-日志配置文件" class="headerlink" title="2. 日志配置文件"></a>2. 日志配置文件</h3><p>日志的配置文件还是依据实现类的不同来完成。毕竟sel4j只是提供一个抽象方法给我们调用。</p><h3 id="3-统一日志系统"><a href="#3-统一日志系统" class="headerlink" title="3. 统一日志系统"></a>3. 统一日志系统</h3><p>一个项目中可能涉及多个框架，而不同的框架使用的是不同的日志接口。我们需要统一日志接口。</p><p>以slf4j为例：</p><ul><li>系统框架中的其它日志系统排除</li><li>用中间包替换原有的日志框架，中间包是一个类似于原有框架，但实际上是转向slf4j的一个包</li><li>导入slf4j的实现类</li></ul><h3 id="4-SpringBoot的日志关系"><a href="#4-SpringBoot的日志关系" class="headerlink" title="4. SpringBoot的日志关系"></a>4. SpringBoot的日志关系</h3><p>通过查看springboot项目的依赖关系图，我们确认了springboot使用的是slf4j作用日志接口，logback作为日志实现；同时，springboot还通过日志转换包，把其它日志系统转为slf4j，然后用logback实现。</p><blockquote><p>SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 排除 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-springboot日志的使用和基本配置"><a href="#5-springboot日志的使用和基本配置" class="headerlink" title="5. springboot日志的使用和基本配置"></a>5. springboot日志的使用和基本配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 记住是导这个包</span><br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot01HelloworldQuickApplicationTests</span> &#123;<br>    <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span>  LoggerFactory.getLogger(getClass());<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 日志的默认输出级别，是info，所以是看不见trace和debug的输出的，但可以在配置文件中调整输出级别</span><br>        logger.trace(<span class="hljs-string">&quot;Trace 信息&quot;</span>);<br>        logger.debug(<span class="hljs-string">&quot;debug 信息&quot;</span>);<br>        logger.info(<span class="hljs-string">&quot;info 信息&quot;</span>);<br>        logger.warn(<span class="hljs-string">&quot;warn 信息&quot;</span>);<br>        logger.error(<span class="hljs-string">&quot;error 信息&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 调整日志级别</span><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com:</span><br>      <span class="hljs-attr">lee:</span> <span class="hljs-string">trace</span><br></code></pre></td></tr></table></figure><p><strong>除了配置日志的级别还可以调整日志的输出格式，输入到本地硬盘的某个位置。</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 不指定路径在当前项目下生成springboot.log日志</span><br><span class="hljs-comment"># 可以指定完整的路径；</span><br><span class="hljs-comment"># logging.file=G:/springboot.log</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># logging.path=指定日志文件的输出路径，日志文件名为spring.log</span><br><span class="hljs-comment"># 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件</span><br><span class="hljs-attr">logging.path</span>=<span class="hljs-string">/spring/log</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#  在控制台输出的日志的格式</span><br><span class="hljs-attr">logging.pattern.console</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br><span class="hljs-comment"># 指定文件中日志输出的格式</span><br><span class="hljs-attr">logging.pattern.file</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n</span><br></code></pre></td></tr></table></figure><h3 id="6-配置日志By文件"><a href="#6-配置日志By文件" class="headerlink" title="6. 配置日志By文件"></a>6. 配置日志By文件</h3><p>日志系统会读取<code>org.springframework.boot.logging</code>包里的配置文件，我们也可以自己写一个类似的配置文件来进行覆盖。<br>有两种方式：</p><ol><li>logback.xml：这种方式会直接被日志系统识别并加载</li><li>logback-spring.xml：日志系统无法识别这种文件，是由springboot解析配置然后加载到日志系统中。这种方式可以使用springboot的高级功能，比如profile功能（环境选择，不同的环境不同的配置）</li></ol><h1 id="四、Web开发"><a href="#四、Web开发" class="headerlink" title="四、Web开发"></a>四、Web开发</h1><h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h2><p>使用springboot开发，idea中使用springboot initializer选择需要的场景模块，然后编写业务代码即可。配置文件部分springboot已经帮我们做了。</p><p>但在使用中我们也需要时常思考，这个场景springboot帮忙我们做了哪些配置，我们能不能修改，能不能进行扩展？</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">xxxxAutoConfiguration:</span> <span class="hljs-string">帮我们给容器中自动配置组件；</span><br><span class="hljs-attr">xxxxProperties:</span> <span class="hljs-string">配置类来封装配置文件的内容；</span><br></code></pre></td></tr></table></figure><h2 id="4-2-静态资源的映射"><a href="#4-2-静态资源的映射" class="headerlink" title="4.2 静态资源的映射"></a>4.2 静态资源的映射</h2><p><strong>先对路径做一下解释</strong><br><img src="/images/2021S4/QQ%E5%9B%BE%E7%89%8720211208170009.png" alt="路径的具体对应"></p><h3 id="4-2-1-webjars引入资源"><a href="#4-2-1-webjars引入资源" class="headerlink" title="4.2.1 webjars引入资源"></a>4.2.1 webjars引入资源</h3><p>这种方式通过jar包的引入资源。比如我们要使用js，就直接在pom中写依赖导入js的webjars包，然后通过<code>localhost:8080/webjars/jquery/3.3.1/jquery.js</code>这种路径访问即可。</p><p><code>classpath:/META-INF/resources/webjars/</code>实际上是真实的路径，但springboot已经使用<code>/webjars</code>替换了。</p><p><a href="http://www.webjars.org/">WebJars</a>查看各种jar的依赖。</p><h3 id="4-2-2-项目静态路径映射"><a href="#4-2-2-项目静态路径映射" class="headerlink" title="4.2.2 项目静态路径映射"></a>4.2.2 项目静态路径映射</h3><p>项目可以直接访问的文件目录，也就是说，用来放资源的目录。以下几个都是项目的静态资源根目录。</p><ul><li>“classpath:&#x2F;META-INF&#x2F;resources&#x2F;“, </li><li>“classpath:&#x2F;resources&#x2F;“,</li><li>“classpath:&#x2F;static&#x2F;“, </li><li>“classpath:&#x2F;public&#x2F;“ </li><li>“&#x2F;“：当前项目的根路径  <strong>重点！</strong></li></ul><p>这几种方式都支持引入资源，<strong>classpath为项目根目录，src和resource都是classpath</strong></p><h4 id="4-2-2-2-首页映射"><a href="#4-2-2-2-首页映射" class="headerlink" title="4.2.2.2 首页映射"></a>4.2.2.2 首页映射</h4><p>首页的映射路径是 <code>**/index</code></p><h4 id="4-2-2-3-网站图标映射"><a href="#4-2-2-3-网站图标映射" class="headerlink" title="4.2.2.3 网站图标映射"></a>4.2.2.3 网站图标映射</h4><p>图标的映射路径是 <code>**/favicon.ico</code></p><h4 id="4-2-3-更改项目静态路径"><a href="#4-2-3-更改项目静态路径" class="headerlink" title="4.2.3 更改项目静态路径"></a>4.2.3 更改项目静态路径</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 可以一次性配置多个，这个变量是个数组</span><br><span class="hljs-attr">spring.resources.static-locations</span> = <span class="hljs-string">path1,path2</span><br></code></pre></td></tr></table></figure><h2 id="4-3-模板引擎"><a href="#4-3-模板引擎" class="headerlink" title="4.3 模板引擎"></a>4.3 模板引擎</h2><p>模板引擎用于显示动态数据，如图所示：<br><img src="/images/2021S4/Template-engine.png" alt="模板引擎的工作"></p><p>jsp也是模板引擎的一种，SpringBoot推荐使用Thymeleaf模板引擎。</p><h3 id="4-3-1-引入thymeleaf"><a href="#4-3-1-引入thymeleaf" class="headerlink" title="4.3.1 引入thymeleaf"></a>4.3.1 引入thymeleaf</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 2.1.6 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 切换thymeleaf版本，1.5.9的springboot配置的thymeleaf版本太老，我们要用新一点的 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">thymeleaf.version</span>&gt;</span>3.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">thymeleaf.version</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- thymeleaf2   layout1--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">thymeleaf-layout-dialect.version</span>&gt;</span>2.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">thymeleaf-layout-dialect.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-3-2-thymeleaf小demo"><a href="#4-3-2-thymeleaf小demo" class="headerlink" title="4.3.2 thymeleaf小demo"></a>4.3.2 thymeleaf小demo</h3><p><img src="/images/2021S4/thymeleaf-grammar.png" alt="thymeleaf语法"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-comment">&lt;!--thymeleaf命名空间--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>FirstPage<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--text转义特殊字符，即直接原样输出值忽略特殊字符--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;hello&#125;&quot;</span>&gt;</span>默认值<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--不转义特殊字符，支持输出各种标签--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:utext</span>=<span class="hljs-string">&quot;$&#123;hello&#125;&quot;</span>&gt;</span>默认值<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--遍历，以及[[]]的语法（和text一样）--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;arr : $&#123;array&#125;&quot;</span>&gt;</span>[[$&#123;arr&#125;]]<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-3-2-1-thymeleaf表达式语法"><a href="#4-3-2-1-thymeleaf表达式语法" class="headerlink" title="4.3.2.1 thymeleaf表达式语法"></a>4.3.2.1 thymeleaf表达式语法</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">Simple</span> <span class="hljs-string">expressions:（表达式语法）</span><br><span class="hljs-attr">Variable</span> <span class="hljs-string">Expressions: $&#123;...&#125;：获取变量值；OGNL；</span><br>    <span class="hljs-attr">1）、获取对象的属性、调用方法</span><br>    <span class="hljs-attr">2）、使用内置的基本对象：</span><br><span class="hljs-comment">        #ctx : the context object.</span><br><span class="hljs-comment">        #vars: the context variables.</span><br><span class="hljs-comment">        #locale : the context locale.</span><br><span class="hljs-comment">        #request : (only in Web Contexts) the HttpServletRequest object.</span><br><span class="hljs-comment">        #response : (only in Web Contexts) the HttpServletResponse object.</span><br><span class="hljs-comment">        #session : (only in Web Contexts) the HttpSession object.</span><br><span class="hljs-comment">        #servletContext : (only in Web Contexts) the ServletContext object.</span><br>        <br>        <span class="hljs-attr">$&#123;session.foo&#125;</span><br>    <span class="hljs-attr">3）、内置的一些工具对象：</span><br><span class="hljs-comment">#execInfo : information about the template being processed.</span><br><span class="hljs-comment">#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.</span><br><span class="hljs-comment">#uris : methods for escaping parts of URLs/URIs</span><br><span class="hljs-comment">#conversions : methods for executing the configured conversion service (if any).</span><br><span class="hljs-comment">#dates : methods for java.util.Date objects: formatting, component extraction, etc.</span><br><span class="hljs-comment">#calendars : analogous to #dates , but for java.util.Calendar objects.</span><br><span class="hljs-comment">#numbers : methods for formatting numeric objects.</span><br><span class="hljs-comment">#strings : methods for String objects: contains, startsWith, prepending/appending, etc.</span><br><span class="hljs-comment">#objects : methods for objects in general.</span><br><span class="hljs-comment">#bools : methods for boolean evaluation.</span><br><span class="hljs-comment">#arrays : methods for arrays.</span><br><span class="hljs-comment">#lists : methods for lists.</span><br><span class="hljs-comment">#sets : methods for sets.</span><br><span class="hljs-comment">#maps : methods for maps.</span><br><span class="hljs-comment">#aggregates : methods for creating aggregates on arrays or collections.</span><br><span class="hljs-comment">#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).</span><br><br><span class="hljs-attr">Selection</span> <span class="hljs-string">Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样；</span><br>    <span class="hljs-attr">补充：配合</span> <span class="hljs-string">th:object=&quot;$&#123;session.user&#125;：</span><br><span class="hljs-attr">&lt;div</span> <span class="hljs-string">th:object=&quot;$&#123;session.user&#125;&quot;&gt;</span><br><span class="hljs-attr">&lt;p&gt;Name</span>: <span class="hljs-string">&lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;</span><br><span class="hljs-attr">&lt;p&gt;Surname</span>: <span class="hljs-string">&lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;</span><br><span class="hljs-attr">&lt;p&gt;Nationality</span>: <span class="hljs-string">&lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;</span><br><span class="hljs-attr">&lt;/div&gt;</span><br><br><span class="hljs-attr">Message</span> <span class="hljs-string">Expressions: #&#123;...&#125;：获取国际化内容</span><br><span class="hljs-attr">Link</span> <span class="hljs-string">URL Expressions: @&#123;...&#125;：定义URL；</span><br>        <span class="hljs-attr">@&#123;/order/process(execId</span>=<span class="hljs-string">$&#123;execId&#125;,execType=&#x27;FAST&#x27;)&#125;</span><br><span class="hljs-attr">Fragment</span> <span class="hljs-string">Expressions: ~&#123;...&#125;：片段引用表达式</span><br>        <span class="hljs-attr">&lt;div</span> <span class="hljs-string">th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt;</span><br>    <br><span class="hljs-attr">Literals（字面量）</span><br>      <span class="hljs-attr">Text</span> <span class="hljs-string">literals: &#x27;one text&#x27; , &#x27;Another one!&#x27; ,…</span><br>      <span class="hljs-attr">Number</span> <span class="hljs-string">literals: 0 , 34 , 3.0 , 12.3 ,…</span><br>      <span class="hljs-attr">Boolean</span> <span class="hljs-string">literals: true , false</span><br>      <span class="hljs-attr">Null</span> <span class="hljs-string">literal: null</span><br>      <span class="hljs-attr">Literal</span> <span class="hljs-string">tokens: one , sometext , main ,…</span><br><span class="hljs-attr">Text</span> <span class="hljs-string">operations:（文本操作）</span><br>    <span class="hljs-attr">String</span> <span class="hljs-string">concatenation: +</span><br>    <span class="hljs-attr">Literal</span> <span class="hljs-string">substitutions: |The name is $&#123;name&#125;|</span><br><span class="hljs-attr">Arithmetic</span> <span class="hljs-string">operations:（数学运算）</span><br>    <span class="hljs-attr">Binary</span> <span class="hljs-string">operators: + , - , * , / , %</span><br>    <span class="hljs-attr">Minus</span> <span class="hljs-string">sign (unary operator): -</span><br><span class="hljs-attr">Boolean</span> <span class="hljs-string">operations:（布尔运算）</span><br>    <span class="hljs-attr">Binary</span> <span class="hljs-string">operators: and , or</span><br>    <span class="hljs-attr">Boolean</span> <span class="hljs-string">negation (unary operator): ! , not</span><br><span class="hljs-attr">Comparisons</span> <span class="hljs-string">and equality:（比较运算）</span><br>    <span class="hljs-attr">Comparators</span>: <span class="hljs-string">&gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )</span><br>    <span class="hljs-attr">Equality</span> <span class="hljs-string">operators: == , != ( eq , ne )</span><br><span class="hljs-attr">Conditional</span> <span class="hljs-string">operators:条件运算（三元运算符）</span><br>    <span class="hljs-attr">If-then</span>: <span class="hljs-string">(if) ? (then)</span><br>    <span class="hljs-attr">If-then-else</span>: <span class="hljs-string">(if) ? (then) : (else)</span><br>    <span class="hljs-attr">Default</span>: <span class="hljs-string">(value) ?: (defaultvalue)</span><br><span class="hljs-attr">Special</span> <span class="hljs-string">tokens:</span><br>    <span class="hljs-attr">No-Operation</span>: <span class="hljs-string">_ </span><br></code></pre></td></tr></table></figure><h2 id="4-4-SpringMVC的自动配置"><a href="#4-4-SpringMVC的自动配置" class="headerlink" title="4.4 SpringMVC的自动配置"></a>4.4 SpringMVC的自动配置</h2><p><a href="https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications">1.5.9的springbootMVC文档地址</a></p><h3 id="4-4-1-SpringMVC自动配置"><a href="#4-4-1-SpringMVC自动配置" class="headerlink" title="4.4.1 SpringMVC自动配置"></a>4.4.1 SpringMVC自动配置</h3><p>Spring Boot 自动配置好了SpringMVC</p><p>以下是SpringBoot对SpringMVC的默认配置:（WebMvcAutoConfiguration）</p><ul><li>Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.<ul><li>自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））</li><li>ContentNegotiatingViewResolver：组合所有的视图解析器的；</li><li>如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；</li></ul></li><li>Support for serving static resources, including support for WebJars (see below).<ul><li>静态资源文件夹路径,webjars</li></ul></li><li>Static index.html support.<ul><li>静态首页访问</li></ul></li><li>Custom Favicon support (see below). <ul><li>图标定义 favicon.ico</li></ul></li><li>自动注册了 of Converter, GenericConverter, Formatter beans.<ul><li>Converter：转换器； public String hello(User user)：类型转换使用Converter   </li><li>Formatter 格式化器； 2017.12.17&#x3D;&#x3D;&#x3D;Date；</li></ul></li></ul><p>自己添加的格式化器转换器，我们只需要放在容器中即可</p><ul><li>Support for HttpMessageConverters (see below).<ul><li>HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json；</li><li>HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter；<ul><li>自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component</li></ul></li></ul></li><li>Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则</li><li>Automatic use of a ConfigurableWebBindingInitializer bean (see below).</li><li>我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）<ul><li>初始化WebDataBinder；</li><li>请求数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;JavaBean；</li></ul></li><li>org.springframework.boot.autoconfigure.web：web的所有自动场景；<blockquote><p>If you want to <strong>keep Spring Boot MVC features</strong>, and you <strong>just want to add additional MVC configuration</strong> (<code>interceptors, formatters, view controllers</code> etc.) you can <strong>add your own <code>@Configuration</code> class of type <code>WebMvcConfigurerAdapter</code>, but without <code>@EnableWebMvc</code></strong>.<br>If you want to <strong>take complete control of Spring MVC</strong>, you can add your own <code>@Configuration </code>annotated <strong>with @EnableWebMvc.</strong><br>If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>，<code>RequestMappingHandlerAdapter</code> or <code>ExceptionHandlerExceptionResolver</code> you can declare a <code>WebMvcRegistrationsAdapter</code> instance providing such components.</p></blockquote></li></ul><h3 id="4-4-2-扩展SpringMVC"><a href="#4-4-2-扩展SpringMVC" class="headerlink" title="4.4.2 扩展SpringMVC"></a>4.4.2 扩展SpringMVC</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/hello&quot;</span> <span class="hljs-attr">view-name</span>=<span class="hljs-string">&quot;success&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/hello&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span>&gt;</span>some.Bean<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这是传统的springmvc的配置片段，配置了一个对hello的映射，同时为它指定一个拦截器some.Bean。</p><p>springboot中，用这段代码实现这些功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMvcConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebMvcConfigurerAdapter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> &#123;<br>       <span class="hljs-comment">// super.addViewControllers(registry);</span><br>        <span class="hljs-comment">//浏览器发送 /atguigu 请求来到 success</span><br>        registry.addViewController(<span class="hljs-string">&quot;/atguigu&quot;</span>).setViewName(<span class="hljs-string">&quot;success&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果只是像扩展MVC功能，只需要编写一个继承自<code>WebMvcConfigurerAdapter</code>类，同时加上<code>@Configuration</code>注解即可。</p><h3 id="4-4-3-第一个页面的映射，login"><a href="#4-4-3-第一个页面的映射，login" class="headerlink" title="4.4.3 第一个页面的映射，login"></a>4.4.3 第一个页面的映射，login</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 映射/和index.html</span><br><span class="hljs-meta">@RequestMapping(&#123;&quot;/&quot;,&quot;/index.html&quot;&#125;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 返回login，springboot在字符串后拼接.html</span><br>    <span class="hljs-comment">// 然后在template文件夹中查找同名文件并进行试图映射</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="4-4-3-1使用WebMvcConfigurerAdapter进行简单映射"><a href="#4-4-3-1使用WebMvcConfigurerAdapter进行简单映射" class="headerlink" title="4.4.3.1使用WebMvcConfigurerAdapter进行简单映射"></a>4.4.3.1使用WebMvcConfigurerAdapter进行简单映射</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMvcConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebMvcConfigurerAdapter</span> &#123;<br>    <span class="hljs-comment">/*视图控制器*/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> &#123;<br>       <span class="hljs-built_in">super</span>.addViewControllers(registry);<br>       registry.addViewController(<span class="hljs-string">&quot;/index.html&quot;</span>).setViewName(<span class="hljs-string">&quot;login&quot;</span>);<br>       registry.addViewController(<span class="hljs-string">&quot;/&quot;</span>).setViewName(<span class="hljs-string">&quot;login&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// adapter的内部类也可以完成映射</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> WebMvcConfigurerAdapter <span class="hljs-title function_">webMvcConfigurerAdapter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">WebMvcConfigurerAdapter</span> <span class="hljs-variable">adapter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebMvcConfigurerAdapter</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> &#123;<br>                registry.addViewController(<span class="hljs-string">&quot;/index.html&quot;</span>).setViewName(<span class="hljs-string">&quot;login&quot;</span>);<br>                registry.addViewController(<span class="hljs-string">&quot;/&quot;</span>).setViewName(<span class="hljs-string">&quot;login&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> adapter;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-4-国际化"><a href="#4-4-4-国际化" class="headerlink" title="4.4.4 国际化"></a>4.4.4 国际化</h3><p>国际化通过配置文件实现。<br><img src="/images/2021S4/QQ%E6%88%AA%E5%9B%BE20211220115546.png" alt="文件结构"></p><p>默认情况下，springboot会读取名为<code>message.properties</code>文件中的国际化信息。所以我们需要在<strong>配置文件</strong>中手动改一下，<code>spring.messages.basename=i18n/login</code>指定我们的国际化文件位置。</p><p>目前idea更改全局项目设置的路径在<code>New Project Setup -&gt; Setting For New Project</code>中，因为要想properties中写中文字符，为了避免乱码，要切换到utf-8。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># login_en_US.properties 英文对应文件</span><br><span class="hljs-attr">login.prompt</span>=<span class="hljs-string">Please sign in</span><br><span class="hljs-attr">login.username</span>=<span class="hljs-string">User name</span><br><span class="hljs-attr">login.password</span>=<span class="hljs-string">Password</span><br><span class="hljs-attr">login.remember</span>=<span class="hljs-string">Remember Me</span><br><span class="hljs-attr">login.bt</span> = <span class="hljs-string">Sign in</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># login_zh_CN.properties 中文对于文件</span><br><span class="hljs-attr">login.prompt</span>=<span class="hljs-string">请登录</span><br><span class="hljs-attr">login.username</span>=<span class="hljs-string">用户名</span><br><span class="hljs-attr">login.password</span>=<span class="hljs-string">密码</span><br><span class="hljs-attr">login.remember</span>=<span class="hljs-string">记住信息</span><br><span class="hljs-attr">login.bt</span> =<span class="hljs-string">登录</span><br></code></pre></td></tr></table></figure><p>完成之后，使用themeleaf获取值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 例子 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;h3 mb-3 font-weight-normal&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#&#123;login.prompt&#125;&quot;</span>&gt;</span>Please sign in<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;remember-me&quot;</span>&gt;</span> [[#&#123;login.remember&#125;]]<br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></table></figure><p>完成这些后，网页就会根据请求头中的位置信息自动切换语言。</p><h4 id="4-4-4-1-手动切换语言"><a href="#4-4-4-1-手动切换语言" class="headerlink" title="4.4.4.1 手动切换语言"></a>4.4.4.1 手动切换语言</h4><p>在页面放置两个超链接，跳到本页面并传递切换的语言信息</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-sm&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/index.html(l=&#x27;zh_CN&#x27;)&#125;&quot;</span>&gt;</span>中文<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-sm&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/index.html(l=&#x27;en_US&#x27;)&#125;&quot;</span>&gt;</span>English<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>创建一个实现了<code>LocaleResovler</code>的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLocaleResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LocaleResolver</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span>  Locale <span class="hljs-title function_">resolveLocale</span><span class="hljs-params">(HttpServletRequest httpServletRequest)</span> &#123;<br>        <span class="hljs-comment">/*从请求中获取要显示的语言*/</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> httpServletRequest.getParameter(<span class="hljs-string">&quot;l&quot;</span>);<br>        <span class="hljs-comment">//    获取默认locale对象</span><br>       <span class="hljs-type">Locale</span> <span class="hljs-variable">locale</span> <span class="hljs-operator">=</span> Locale.getDefault();<br>       <span class="hljs-keyword">if</span>(StringUtils.hasLength(l))&#123;<br>           logger.info(l);<br>           String[] ls = l.split(<span class="hljs-string">&quot;_&quot;</span>);<br>           locale = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Locale</span>(ls[<span class="hljs-number">0</span>],ls[<span class="hljs-number">1</span>]);<br>       &#125;<br>       <span class="hljs-keyword">return</span> locale;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后把locale注册到MyMvcConfig类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br>   <span class="hljs-keyword">public</span> LocaleResolver <span class="hljs-title function_">localeResolver</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-comment">// 如果没有注册，springboot使用自己的，如果我们自己注册了，springboot就会使用我们的。</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyLocaleResolver</span>();<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-5访问控制"><a href="#4-4-5访问控制" class="headerlink" title="4.4.5访问控制"></a>4.4.5访问控制</h3><ol><li>使用<code>th:action=&quot;@&#123;/user/login&#125;&quot;</code>发送登录请求</li><li>控制器处理映射<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(value = &quot;/user/login&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;username&quot;)</span> String username,</span><br><span class="hljs-params">                        <span class="hljs-meta">@RequestParam(&quot;password&quot;)</span> String password,</span><br><span class="hljs-params">                        Map&lt;String,Object&gt; map, HttpSession session)</span>&#123;<br>        <span class="hljs-comment">/*带有RequestParam的参数没有被接收到， 就会报错  xxx not present */</span><br>        <span class="hljs-keyword">if</span>(StringUtils.hasLength(username) &amp;&amp; <span class="hljs-string">&quot;aaaaaa&quot;</span>.equals(password))&#123;<br>            <span class="hljs-comment">/* 登陆成功存值到session */</span><br>            session.setAttribute(<span class="hljs-string">&quot;loginUser&quot;</span>,username);<br>            <span class="hljs-comment">/* 通过重定向避免出现表单重复提交的问题</span><br><span class="hljs-comment">            重定向到一个不存在main.html</span><br><span class="hljs-comment">            然后由视图控制器绑定到要跳转的页面 */</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/main.html&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">/* 存到map的值待会用模板引擎解析 */</span><br>            map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;用户名或密码错误&quot;</span>);<br>            <span class="hljs-comment">/* 未登录回到首页，这里的return是与template建立连接 */</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li>建立一个<code>LoginHandlerInterceptor</code>拦截器拦截未登陆访问 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">    &lt;!-- 实现HandlerInterceptor --&gt;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginHandlerInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> httpServletRequest.getSession().getAttribute(<span class="hljs-string">&quot;loginUser&quot;</span>);<br>        <span class="hljs-keyword">if</span>(user == <span class="hljs-literal">null</span>)&#123;<br>            httpServletRequest.setAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;请先登录~&quot;</span>);<br>            <span class="hljs-comment">/* 如果未登录，跳转到登录页 */</span><br>            httpServletRequest.getRequestDispatcher(<span class="hljs-string">&quot;/index.html&quot;</span>).forward(httpServletRequest,httpServletResponse);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>注册拦截器，在MyMvcConfig中注册，MyMvcConfig用于定制扩展springboot<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> WebMvcConfigurerAdapter <span class="hljs-title function_">webMvcConfigurerAdapter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">WebMvcConfigurerAdapter</span> <span class="hljs-variable">adapter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebMvcConfigurerAdapter</span>() &#123;<br>            <span class="hljs-comment">// 视图映射器</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> &#123;<br>                registry.addViewController(<span class="hljs-string">&quot;/index.html&quot;</span>).setViewName(<span class="hljs-string">&quot;login&quot;</span>);<br>                registry.addViewController(<span class="hljs-string">&quot;/&quot;</span>).setViewName(<span class="hljs-string">&quot;login&quot;</span>);<br>                registry.addViewController(<span class="hljs-string">&quot;/main.html&quot;</span>).setViewName(<span class="hljs-string">&quot;dashboard&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-comment">/*注册拦截器*/</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>                registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginHandlerInterceptor</span>()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>                        .excludePathPatterns(<span class="hljs-string">&quot;/index.html&quot;</span>,<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-string">&quot;/user/login&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> adapter;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="4-4-5-1关于热部署"><a href="#4-4-5-1关于热部署" class="headerlink" title="4.4.5.1关于热部署"></a>4.4.5.1关于热部署</h4><p>两个前提</p><ol><li>是在debug模式下</li><li>禁用模板引擎的缓存(使静态页面生效),<code>spring.thymeleaf.cache=false</code></li></ol><h3 id="4-4-6-员工列表模拟Restful"><a href="#4-4-6-员工列表模拟Restful" class="headerlink" title="4.4.6 员工列表模拟Restful"></a>4.4.6 员工列表模拟Restful</h3><ol><li><p>对应的uri：<br> URI：  &#x2F;资源名称&#x2F;资源标识       HTTP请求方式区分对资源CRUD操作</p><table><thead><tr><th></th><th>普通CRUD（uri来区分操作）</th><th>RestfulCRUD</th></tr></thead><tbody><tr><td>查询</td><td>getEmp</td><td>emp—GET</td></tr><tr><td>添加</td><td>addEmp?xxx</td><td>emp—POST</td></tr><tr><td>修改</td><td>updateEmp?id&#x3D;xxx&amp;xxx&#x3D;xx</td><td>emp&#x2F;{id}—PUT</td></tr><tr><td>删除</td><td>deleteEmp?id&#x3D;1</td><td>emp&#x2F;{id}—DELETE</td></tr></tbody></table></li><li><p>请求架构</p><table><thead><tr><th>实验功能</th><th>请求URI</th><th>请求方式</th></tr></thead><tbody><tr><td>查询所有员工</td><td>emps</td><td>GET</td></tr><tr><td>查询某个员工(来到修改页面)</td><td>emp&#x2F;1</td><td>GET</td></tr><tr><td>来到添加页面</td><td>emp</td><td>GET</td></tr><tr><td>添加员工</td><td>emp</td><td>POST</td></tr><tr><td>来到修改页面（查出员工进行信息回显）</td><td>emp&#x2F;1</td><td>GET</td></tr><tr><td>修改员工</td><td>emp</td><td>PUT</td></tr><tr><td>删除员工</td><td>emp&#x2F;1</td><td>DELETE</td></tr></tbody></table></li><li><p>处理获取所有员工列表的控制器</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/emp/list&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">list</span><span class="hljs-params">(Model model)</span>&#123;<br>    Collection&lt;Employee&gt; emps =  employeeDao.getAll();<br>    model.addAttribute(<span class="hljs-string">&quot;emps&quot;</span>,emps);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;emp/list&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>抽取页面公共元素的两种方式，<code>dashboard</code>是模板名称</p><ol><li><code>th:fragment=&quot;top-nav&quot;</code> 给公共元素的fragment命名，然后<code>&lt;div th:replace=&quot;dashboard :: top-nav&quot;&gt;&lt;/div&gt;</code>使用。外层的这个div会被里面的代码覆盖</li><li>直接在要引用的地方<code>&lt;div th:replace=&quot;dashboard :: #sidebar&quot;&gt;&lt;/div&gt;</code>使用选择器引入</li></ol></li></ol><p>–</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>框架</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宁静春夏——2021年中总结</title>
    <link href="/2021/07/%E9%A3%8E%E5%B9%B3%E6%B5%AA%E9%9D%99%E7%9A%84%E6%98%A5%E5%92%8C%E5%A4%8F/"/>
    <url>/2021/07/%E9%A3%8E%E5%B9%B3%E6%B5%AA%E9%9D%99%E7%9A%84%E6%98%A5%E5%92%8C%E5%A4%8F/</url>
    
    <content type="html"><![CDATA[<p>上一个春季学期也是挺无聊的，在家混了大半个学期，什么都没完成。这个学期虽然没上个学期那么无聊，但也没发生什么我想要完成的事。</p><span id="more"></span><h2 id="失败的一个学期"><a href="#失败的一个学期" class="headerlink" title="失败的一个学期"></a>失败的一个学期</h2><p><img src="/images/2021S3/happing_vacation.jpg" alt="“愉快”的五一假期，结束自习"><br>还是在回到家我爸问我这学期考到什么证书没有，我才猛地想起，<strong>我这学期在学习上的几乎是原地踏步。</strong></p><p>这学期没有不仅考到什么证书，一些可以加分的机会也被我白白错过。心心念念的四级这学期依然没有开放报名。专业的扩展学习这学期也没有太大进步，那这学期时间都花在哪儿了呢？时间用在了日常的课程的学习，花在Android上的时间多。奖学金是没希望了，<strong>所以我现在的目标是四川省优秀毕业生。</strong></p><p>加分机会的错过得怪我没有早些研究综测的加分机会。</p><p>这学期在专业扩展学习上的失败，对下学期也会产生许多负面的影响，下学期我将在专业、数学、扩展学习三个之间徘徊。这肯定也会浪费许多时间。</p><h2 id="成功的一个学期"><a href="#成功的一个学期" class="headerlink" title="成功的一个学期"></a>成功的一个学期</h2><p><img src="/images/2021S3/taikongnaut.jpg" alt="宇航员积木"><br><strong>我这学期算是吧失败乃成功之母这句名言也理解透了。</strong></p><p>某次班会上，班导对同学们面对各种活动时消极态度的态度的评价可以说是让我醍醐灌顶，也让我明白，即使有些是希望渺茫，但至少尝试了总归有那么一点概率成功。<strong>有些事情，不去尝试，连失败的资格都没有。</strong> 这句鸡汤很对我胃口。</p><ul><li>我在逐渐适应记笔记的学习方式</li><li>暑期前期我通过出去找工作的经历获得了许多焦虑感，算得上是一剂肾上腺素</li><li>一些神奇的事情使我获得了更多的自信</li></ul><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p><img src="/images/2021S3/lightning.jpg" alt="纯真的⚡"><br>错过高考的报名时间让我意识到我应该扩展线上的消息渠道，而因为觉得某件事希望太渺茫导致错过许多得分机会让我意识到我应该扩展多吸取一些过来人的经验，一些我先去认为是在扯把子的经验。</p><p>暑期在成都找工作的经历让我提前体验了明年出去实习时的感觉。</p><p>然后老家找工作的经历让我明白，如果我当初没有读大学，要想在小城市活下去也不难，但能有这样的想法是我在经历的大学的洗礼之后才有的。我不确定读大学前的我会不会也能有这样的观点。</p><ul><li>这几天，我面试了，房地产销售、装修销售、充电宝地推、音响安装布线，感觉，销售是真的能赚钱。尤其是卖房子，一个月就算之卖出去一套，一个月也能有7k-8k。<del>我已经开始动摇了，lol</del></li></ul><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p><img src="/images/2021S3/flying.jpg" alt="起飞阶段的飞机"><br>暑假期间，5号前学完前端基础。完美的目标是完整了解一个框架。暑假前学完SSM，完美目标是结合之前的前端技术做出一个实战项目。</p><p>当这两个的完美目标完成，你<strong>天文望远镜</strong>就有了。</p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p><img src="/images/2021S3/siyuanlou.jpg" alt="从思源楼看"></p><p><strong>无论暑假期间的学习如何，下学期应该把1&#x2F;3的课余学习时间分给高数</strong></p><p><strong>无论暑假期间的学习如何，下学期应该把1&#x2F;3的课余学习时间分给高数</strong></p><p><strong>无论暑假期间的学习如何，下学期应该把1&#x2F;3的课余学习时间分给高数</strong></p><p>高数对我太重要了，也是我最大的弱点。英语的基础还在，计算机死背。<br>这三个科目，只要高数是最大的弱点，也是我最担心的。</p><p>因为我不确定到时候我会不会出去实习，<strong>如果我出去实现，那么我是否能有足够的多时间来复习专升本。</strong>我不能把最重要同时也是最需要时间的科目留到最后去。</p><p>上次单招考试只差一分录取让我意识到一分到底有多重要。</p><p><strong>这次对于考试大纲一定要一定要一定要熟悉到倒背如流的程度</strong>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂谈</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS基础</title>
    <link href="/2021/07/CSS%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/07/CSS%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>css是一种定义网页外观的技术。css的中文名叫<strong>层叠样式表</strong>，css使用各种各样的样式来改变html标签原来的样子，<strong>同时多种样式也允许叠加在一个标签上</strong>。</p><span id="more"></span><p>css可以改变网页的外观，给网页加上动画，改变背景颜色等…</p><h3 id="css语法"><a href="#css语法" class="headerlink" title="css语法"></a>css语法</h3><p>css使用选择器来选择一个或多个html标签，然后通过声明样式来加上各种各样的效果。每一条 css 以分号结束。</p><p><img src="/images/2021S2/css_entity.jpg" alt="一个 CSS"></p><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p>在标签指定 id 或 class 属性后,就能给在 css 里使用选择器了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-id">#head1</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">color</span>:red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.head</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">h1</span><span class="hljs-selector-class">.cla</span>&#123;</span><br><span class="language-css">        <span class="hljs-comment">/* 这个选择器选择 class 属性为 cla 的 h1 标签 */</span></span><br><span class="language-css">        <span class="hljs-attribute">color</span>:gray;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">p</span>&#123;</span><br><span class="language-css">        <span class="hljs-comment">/* 选中p标签 */</span></span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.head</span> <span class="hljs-selector-tag">p</span>&#123;</span><br><span class="language-css">        <span class="hljs-comment">/* 选中 class 属性为 head 内的 p 标签 */</span></span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.head</span>&#123;</span><br><span class="language-css">        <span class="hljs-comment">/* 选中带有 class 为 head 的p标签 */</span></span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;head&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;head1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>#head1</code>通过id选中<code>h1</code>，并指定它的字体颜色为红色，<code>.head</code>通过class选中<code>h1</code>，然后指定它的背景颜色为蓝色。</p><h4 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h4><p><strong>前面提到过，使用css有三种方式，内联、内部、外部。假如它们都选中同一个标签，然后给它加上不同的颜色，这时将遵循就近原则，距离标签越近的css属性优先级越高。</strong></p><p>此外，<strong>选择器还有根据精准度而生成的权重值</strong>。权重越大，优先级越高。比如，id选择器就比class选择器精度高，所有它的权重就大于class选择器。选择器权重值可以通过多个选择器叠加。</p><p><strong>如果给样式加上<code>!important</code>这时选择器的优先级将最大化，</strong>将会覆盖其它选择器的样式。如果两个<code>!important</code>冲突的话，那么还是看谁的选择器权重大了。</p><p><a href="https://www.runoob.com/cssref/css-selectors.html">css选择器手册</a></p><h4 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h4><p>多个选择器可以组合使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-comment">/* 后代选择器，将会选中所以div标签以及div子标签中的所有p元素 */</span><br>&#125;<br><br><span class="hljs-selector-tag">div</span>&gt;<span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-comment">/* 子元素选择器，选中所有嵌套在div中的p元素 */</span><br>&#125;<br><br><span class="hljs-selector-tag">div</span>+<span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-comment">/* 相邻同级选择器，选中跟在div后面的p元素 */</span><br>&#125;<br><br><span class="hljs-selector-tag">div</span>~<span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-comment">/* 同级选择器，选中所有div的同级p元素 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><p>属性选择器可以选择带有特性属性的html标签</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[title]</span>&#123;<br>    <span class="hljs-comment">/* 选中所有带有title属性的元素 */</span><br>&#125;<br><br><span class="hljs-selector-attr">[title=head]</span>&#123;<br>    <span class="hljs-comment">/* 选中所有title属性值为&#x27;head&#x27;的元素 */</span><br>&#125;<br><br><span class="hljs-selector-attr">[title~=head]</span>&#123;<br>    <span class="hljs-comment">/* 选中title属性中包含head单词的元素 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><p>使用特殊的关键字来选中元素，这就是伪类。一般用于选中整个标签，它针对的是出于某种特定状态的元素，这个状态是动态变化的。</p><blockquote><p>伪类选择元素基于的是当前元素处于的状态，或者说元素当前所具有的特性，而不是元素的id、class、属性等静态的标志。由于状态是动态变化的，所以一个元素达到一个特定状态时，它可能得到一个伪类的样式；当状态改变时，它又会失去这个样式。由此可以看出，它的功能和class有些类似，但它是基于文档之外的抽象，所以叫伪类。——<em>Leon</em></p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 链接伪类 */</span><br>    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<br>        <span class="hljs-comment">/* 选中所有没有访问过的链接 */</span><br>    &#125; <br>    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br>        <span class="hljs-comment">/* 选中访问过的链接 */</span><br>    &#125;<br>    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>        <span class="hljs-comment">/* 鼠标悬浮时的链接 */</span><br>    &#125;<br>    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<br>        <span class="hljs-comment">/* 点击时的链接 */</span><br>    &#125;<br><span class="hljs-comment">/* 使用链接伪类时，注意遵循上面的顺序 */</span><br><br><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-child&#123;<br>    <span class="hljs-comment">/* 选中p标签，它需要是某个标签的子元素，并且是第一个 */</span><br>&#125;<br><br><span class="hljs-selector-tag">p</span> &gt; <span class="hljs-selector-tag">i</span><span class="hljs-selector-pseudo">:first</span>-child<br>&#123;<br>    <span class="hljs-comment">/* 选中所有p标签内第一个i元素 */</span><br>&#125;<br><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-child <span class="hljs-selector-tag">i</span><br>&#123;<br>    <span class="hljs-comment">/* 从上面的例子中猜一下 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/css/css-pseudo-classes.html">更多的伪类选择器…</a></p><h4 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h4><p>伪元素选择器通常选中标签内的某些内容，比如第一行，第一个字母等</p><blockquote><p>与伪类针对特殊状态的元素不同的是，伪元素是对元素中的特定内容进行操作，它所操作的层次比伪类更深了一层，也因此它的动态性比伪类要低得多。实际上，设计伪元素的目的就是去选取诸如元素内容第一个字（母）、第一行，选取某些内容前面或后面这种普通的选择器无法完成的工作。它控制的内容实际上和元素是相同的，但是它本身只是基于元素的抽象，并不存在于文档中，所以叫伪元素。——<em>Leon</em></p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-line&#123;<br>    <span class="hljs-comment">/* 选中p标签内的第一行 */</span><br>&#125;<br><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-letter&#123;<br>    <span class="hljs-comment">/* 选中p标签内第一个字母，first-letter只能用于块级元素 */</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="CSS修改文本"><a href="#CSS修改文本" class="headerlink" title="CSS修改文本"></a>CSS修改文本</h3><p>css可以用来修改文字的颜色，排版等。</p><h4 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h4><p>使用 &#96;body{color: red}属性可以修改文本颜色值，颜色值可以是它的名字、十六进制色或一个RGB值。</p><h4 id="文本对齐方式"><a href="#文本对齐方式" class="headerlink" title="文本对齐方式"></a>文本对齐方式</h4><p><code>text-align</code>属性来定义文本的对齐方式，<strong>有center（居中）、justify（两端对齐）、right（右对齐）值。</strong><br>比如：<code>body&#123;text-align:center&#125;</code></p><h4 id="文本装饰"><a href="#文本装饰" class="headerlink" title="文本装饰"></a>文本装饰</h4><p>使用<code>text-decoration</code>来修改文本的装饰，实际使用主要是对隐藏超链接的下划线。可以使用，<code>overline（上划线），light-throug（中间线）和underline（下划线）</code>。<br><a href="https://www.runoob.com/css/css-text.html">更多文本属性参考</a></p><h3 id="CSS字体"><a href="#CSS字体" class="headerlink" title="CSS字体"></a>CSS字体</h3><p>字体属性可以修改加粗，大小等</p><h4 id="改变字体"><a href="#改变字体" class="headerlink" title="改变字体"></a>改变字体</h4><p>使用<code>font-family</code>可以定义文本的字体，字体可以使用本地字库或者在线字库，常见的字体值有：<code>Serif, Times, Monospace</code>等。</p><h4 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h4><p><code>font-size</code>指定文本的大小，可以使用px,em,rem三种单位。第一个是绝对单位，后两个是相对单位，转换方式为1em≈16px。<strong>推荐使用相对单位以适应不同的浏览器窗口尺寸。</strong></p><h3 id="CSS列表"><a href="#CSS列表" class="headerlink" title="CSS列表"></a>CSS列表</h3><p>对于列表，css可以修改它列表项的样式，比如改成图片，取消列表项等。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span><br>&#123;<br>    &lt;!-- type值表示列表项外观，<span class="hljs-attribute">none</span>表示隐藏列表项 --&gt;<br>    <span class="hljs-attribute">list-style-type</span>: none;<br>    &lt;!-- 在 url 中填入图片地址就能把列表项改成图片 --&gt;<br>    <span class="hljs-attribute">list-style-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;sqpurple.gif&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h3><p>每一个块级元素都是一个盒子，如图所示，它们都有内容区域、边框和内外边距。<br><img src="/images/2021S2/css_box.png" alt="盒模型"></p><p><strong>margin越大，每个html元素之间的间隔就越大；Margin定义元素之间的距离。</strong></p><p><strong>padding越大，元素就会越小;padding定义元素边框到元素实际显示内容的距离。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>&#123;<br>    <span class="hljs-comment">/* 这会把上下边距各设置为2em，左右各设置为4em，顺序为从上开始顺时针 */</span><br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">2em</span> <span class="hljs-number">4em</span> <span class="hljs-number">2em</span> <span class="hljs-number">4em</span>;<br><br>    <span class="hljs-comment">/* 如果直填一个值，将会把全部padding设置为2em */</span><br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">2em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>margin 的单位可以除了设置为具体的长度外，还可以设置为百分比。margin 还可用设置为负值<del>，黑洞?</del></p><p>margin区域没有背景颜色</p><h3 id="CSS边框"><a href="#CSS边框" class="headerlink" title="CSS边框"></a>CSS边框</h3><p>通过<code>border</code>属性即可指定元素的边框属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>&#123;<br>    <span class="hljs-comment">/* border-style指定边框的样式 */</span><br>    <span class="hljs-attribute">border-style</span>: solid;<br><br>    <span class="hljs-comment">/* 更常用的做法，分别设置宽度，颜色，样式 */</span><br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> red solid;<br><br>    <span class="hljs-comment">/* 还可用指定边框的圆角属性，属性越大，边框越远 */</span><br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br><br>    <span class="hljs-comment">/* 边框也支持单独设置某一边 */</span><br>    <span class="hljs-attribute">border-top-style</span>: dotted;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="补充——CSS轮廓"><a href="#补充——CSS轮廓" class="headerlink" title="补充——CSS轮廓"></a>补充——CSS轮廓</h4><p>在布局中我们有时候会使用边框来凸显某个元素，不过更适合的方法是使用轮廓实现，<strong>轮廓不会增加元素的宽度或者宽度，轮廓包裹在元素的边框外面。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">h1</span>&#123;<br>    <span class="hljs-comment">/* 这个将在元素边框外叠加一层红色单实线1px的边框 */</span><br>    <span class="hljs-attribute">outline</span>: red solid <span class="hljs-number">1px</span>;<br>    <span class="hljs-comment">/* 轮廓和边框很相似，上面这个参数表和边框的参数表正好相反 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS元素的显示"><a href="#CSS元素的显示" class="headerlink" title="CSS元素的显示"></a>CSS元素的显示</h3><p>通过display属性可以设置元素的显示方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>&#123;<br>    <span class="hljs-comment">/* none 和 hidden 都能隐藏元素，</span><br><span class="hljs-comment">    不过不同的是，hidden 后的元素还是会占据布局控件，而 none不会*/</span><br>    <span class="hljs-attribute">display</span>: none;<br>    <span class="hljs-attribute">visibility</span>: hidden;<br><br>    <span class="hljs-comment">/* block 和 inline 能让元素在块级和内联直接切换 */</span><br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">display</span>: inline;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS定位"><a href="#CSS定位" class="headerlink" title="CSS定位"></a><a href="https://www.runoob.com/css/css-positioning.html">CSS定位</a></h3><p>CSS一共有5中定位方式，通过position属性修改元素的定位属性。</p><p><strong>首先是默认的static定位方式，这时定位将遵循默认的规则，块级元素换行显示，行内元素紧贴上一个元素显示。</strong></p><h4 id="Relative定位"><a href="#Relative定位" class="headerlink" title="Relative定位"></a>Relative定位</h4><p><strong>相对定位，这里的相对指的是相对元素本来应该在文档流中的位置。在我们修改了元素的默认定位属性后</strong>，比如这里改成了相对定位，就可以通过<code>top,right,bottom,left</code>四个属性调整元素的位置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>&#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">20em</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">5em</span>;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">5em</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">5em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里通过相对定位，将把从元素到top的距离增加20em。其它的几个同理。</p><h4 id="Absolute绝对定位"><a href="#Absolute绝对定位" class="headerlink" title="Absolute绝对定位"></a>Absolute绝对定位</h4><p><strong>绝对定位，绝对定位和相对定位作用一样，只是绝对定位的参照物是最近的已经修改的定位的元素（position!&#x3D;static)，如果没有默认参照html。</strong></p><p>所以很多种情况下，绝对定位呈现出来的效果都像是参照浏览器窗口定位似的。</p><p>实际使用时，通常会在绝对定位的元素外套一个相对定位的<code>div</code>来组合定位</p><h4 id="Fixed"><a href="#Fixed" class="headerlink" title="Fixed"></a>Fixed</h4><p>固定定位可以使某个元素固定在浏览器的某个位置，<strong>相对浏览器窗口定位。</strong></p><h4 id="Sticky"><a href="#Sticky" class="headerlink" title="Sticky"></a>Sticky</h4><p>Sticky定位是前面两种定位<code>relative</code>和<code>fixed</code>的结合。当元素在浏览器的可视范围时，它相对正常文档流定位，当元素快要离开浏览器可视范围时，它将呈现出<code>fixed</code>的定位行为，固定在窗口某个位置。</p><p>简言之，<strong>Sticky定位可以使元素永远显示在窗口某个位置。</strong></p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>每个元素都有一个<code>z-index</code>属性，原来设置元素的z轴高度，很明显高度越高的元素将显示在其它元素的上面。</p><p>通过<code>overflow</code>属性控制元素内容在溢出时的处理方式，可选值为<code>scroll,hidden,auto,visible(默认)</code>，visible表示元素在溢出时直接按照正常方式显示。</p><h3 id="CSS的浮动"><a href="#CSS的浮动" class="headerlink" title="CSS的浮动"></a>CSS的浮动</h3><p><strong>少用float，float设计出来的目的是用于呈现图片和文字混排的功能，而非布局。</strong></p><p>通过元素的float属性，可以使元素向左或者向右浮动。带有浮动属性的元素会一边靠近，直到margin碰到</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.float</span>&#123;<br>    <span class="hljs-attribute">float</span>：<span class="hljs-attribute">right</span>;<br>    <span class="hljs-comment">/* 此外属性值还可以是</span><br><span class="hljs-comment">    left,</span><br><span class="hljs-comment">    none,</span><br><span class="hljs-comment">    inherit 继承父元素的浮动属性</span><br><span class="hljs-comment">    */</span><br>    <br>    <span class="hljs-comment">/* 清除浮动效果 */</span><br>    <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure><p>浮动元素的有一个高度塌陷的特性，浮动元素的<code>height</code>值为0。</p><p>要清除float效果，使用clear属性。</p><h3 id="CSS对齐"><a href="#CSS对齐" class="headerlink" title="CSS对齐"></a>CSS对齐</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.center</span>&#123;<br>    <span class="hljs-comment">/* 实现元素居中对齐效果，仅对块级元素有效 */</span><br>    <span class="hljs-attribute">margin</span>: auto;<br><br>    <span class="hljs-comment">/* 元素内文本居中对齐 */</span><br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-comment">/* 除了上面两个之外，还可以使用float和position来实现对齐效果 */</span><br><br><br>    <span class="hljs-comment">/* 元素垂直对齐 */</span><br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 设置行高也能实现垂直对齐，属性值为父元素的高度 */</span><br>    <span class="hljs-attribute">line-height</span>: x px;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS媒体类型"><a href="#CSS媒体类型" class="headerlink" title="CSS媒体类型"></a>CSS媒体类型</h3><p>媒体类型的使用可以使我们的网页在面对不同媒介时呈现出不同的效果。使用<code>@media</code>设置媒体属性效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen&#123;<br>    <span class="hljs-comment">/* 显示在屏幕上的效果 */</span><br>    <span class="hljs-attribute">color</span> : pink;<br>&#125;<br><span class="hljs-keyword">@media</span> print&#123;<br>    <span class="hljs-comment">/* 在打印机上的效果 */</span><br>    <span class="hljs-attribute">color</span> : black;<br>&#125;<br><span class="hljs-keyword">@media</span> screen,print&#123;<br>    <span class="hljs-comment">/* 多选 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/css/css-mediatypes.html">更多的媒体设备类型…</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于HTML的标签</title>
    <link href="/2021/07/%E5%85%B3%E4%BA%8EHTML%E7%9A%84%E6%A0%87%E7%AD%BE/"/>
    <url>/2021/07/%E5%85%B3%E4%BA%8EHTML%E7%9A%84%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<p>HTML文件中的所以内容都是用标签来修饰的。这些标签也被称为<strong>HTML元素，元素的内容则是开始标签和结束标签之间的内容。</strong>这些元素还支持嵌套使用。</p><span id="more"></span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        ...<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        ...<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>比如在这个只有结构的文档中，<code>&lt;body&gt;</code>标签就是嵌套在<code>&lt;html&gt;</code>标签中的。</p><h2 id="标签的语法"><a href="#标签的语法" class="headerlink" title="标签的语法"></a>标签的语法</h2><p>目前我们见到的标签几乎都是双标签，但HTML也定义了相当数量的单标签，比如<code>&lt;img&gt;</code>，定义图片、<code>&lt;hr&gt;</code>定义一道线。</p><p>HTML语法算是容错机制很强的了，一些标签即使你忘记关闭，也能被浏览器正确解析，但不介意这么做。同时，使用大写或者小写定义标签都是可以显示的，不过w3c<strong>建议使用小写定义标签。</strong></p><h2 id="常见的标签"><a href="#常见的标签" class="headerlink" title="常见的标签"></a>常见的标签</h2><ul><li><code>&lt;h1&gt;</code> 定义标题，使用标题不仅仅至少把字体变大，这也有利与浏览器分析文档的结构</li><li><code>&lt;p&gt;</code> 定义段落</li><li><code>&lt;a&gt;</code> 定义锚点(Anchor)，可以指向其它HTML文档或者本文档的某个位置</li><li><code>&lt;img&gt;</code> 定义一张图片</li><li><code>&lt;br&gt;</code> 手动换行，对于HTML中的连续空格或者换行，浏览器会将其视为一个空格，所以如果需要换行就需要使用<code>&lt;br&gt;</code>标签</li><li><a href="https://www.runoob.com/tags/ref-byfunc.html">更多标签…</a></li></ul><h2 id="标签的属性"><a href="#标签的属性" class="headerlink" title="标签的属性"></a>标签的属性</h2><p><strong>HTML的标签几乎都有它自己的属性，属性写在开始标签中。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;www.example.com&quot;</span>&gt;</span>一个链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>比如这个<code>&lt;a&gt;</code>标签，它有一个<code>href</code>属性，这个属性用来指定跳转的地址。<strong>属性总是以键值对的方式指定， 属性名&#x3D;属性值 。</strong></p><h3 id="标签通用的属性："><a href="#标签通用的属性：" class="headerlink" title="标签通用的属性："></a>标签通用的属性：</h3><ul><li>class 给标签分配一个类名</li><li>id 给标签分配一个id</li><li>style 指定标签的样式属性</li><li>title 指定标签的附加信息（鼠标悬浮在标签内容上时显示）<br> -<a href="https://www.runoob.com/tags/ref-standardattributes.html">更多标签属性…</a></li></ul><h2 id="HTML基本标签的使用"><a href="#HTML基本标签的使用" class="headerlink" title="HTML基本标签的使用"></a>HTML基本标签的使用</h2><p>HTML中有大量的标签用于描述各种各样的内容，文本，图片，视频等，我们先从文本开始。</p><h3 id="文本格式化"><a href="#文本格式化" class="headerlink" title="文本格式化"></a>文本格式化</h3><ul><li><code>&lt;b&gt;</code> 可以将文本<strong>加粗</strong></li><li><code>&lt;strong&gt;</code> 强调文本，默认的显示效果和<code>&lt;b&gt;</code><b>加粗</b>是一样的。 </li><li><code>&lt;i&gt;</code> 将文字变成<em>斜体</em></li><li><code>&lt;sub&gt;</code> 定义<sub>下标文字</sub></li><li><code>&lt;sup&gt;</code> 定义<sup>上标文字</sup></li><li><code>&lt;ins&gt;</code> 定义<ins>插入字</ins></li><li><code>&lt;del&gt;</code> 定义<del>删除字</del></li><li><code>&lt;abbr&gt;</code> 定义<abbr title="也就是这种效果">缩写</abbr>，通过标签的<code>title</code>属性定义全称。</li><li><a href="https://www.runoob.com/html/html-formatting.html/">更多标签</a></li></ul><p>单就从默认的显示效果上来说的话，<code>&lt;b&gt;</code>和<code>&lt;strong&gt;</code>是一样的。它们的区别体现在，用<code>&lt;strong&gt;</code>修饰的文本除了在视觉上有了加粗效果外，还有对其中的文本加上强调的意义，这有利于屏幕阅读器理解内容；而<code>&lt;b&gt;</code>标签仅仅是给修饰的文本带上加粗效果。</p><h3 id="lt-a-gt-Anchor"><a href="#lt-a-gt-Anchor" class="headerlink" title="&lt;a&gt; Anchor"></a><code>&lt;a&gt;</code> Anchor</h3><p>超链接可以说是HTML最突出的特点了，使用它可以把众多的网页连接在一起。<br><code>&lt;a href=&quot;https://www.gogle.com&quot;&gt;Google&lt;/a&gt;</code> 定义了一个到Google的超链接，<code>&lt;a&gt;</code>标签之间的内容不一定是文本，也可以是图片等。</p><p><code>target</code>，超链接的<code>target</code>属性用于定义浏览器打开超链接的方式；<br><code>_blank</code>值表示新开一个标签页打开，，<code>_self</code>表示在当前标签页打开。</p><ul><li><p><a href = "https://www.baidu.com/" target="_black">_blank打开</a></p></li><li><p><a href = "https://www.baidu.com/" target="_self">_self打开</a></p></li></ul><p>超链接除了导向其它<code>HTML</code>页面，还能定位到本文档的某个位置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;top&quot;</span>&gt;</span>顶部<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 如果想要使 a 标签跳转到 h1，需要给 h1 自定义一个 id 属性，</span><br><span class="hljs-comment">任何把 a 标签的 href 属性写出 #&#x27;h1的id&#x27; 就可以了 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;#top&quot;</span>&gt;</span>返回顶部<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="#HTML%E5%9F%BA%E6%9C%AC%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%BF%E7%94%A8">返回 h1</a></p><h2 id="HTML-中的-head"><a href="#HTML-中的-head" class="headerlink" title="HTML 中的 head"></a>HTML 中的 head</h2><p>前面提到过，<code>&lt;head&gt;</code>标签对中的内容，是用来描述网页的，而不是像<code>&lt;body&gt;</code>那样显示在页面上。</p><p><code>&lt;head&gt;</code>中常见的标签</p><ul><li><code>title</code>定义文档显示在浏览器顶部的标题</li><li><code>link</code> 用于引用外部文件，比如引入外部css或者外部js文件，也可以用它在<code>head</code>中引入一张图片。这张图片将作为网页图标显示。</li><li><code>seyle</code>定义文档内部的css样式</li><li><code>script</code>定义网页的脚本文件</li><li><code>meta</code> meta定义网页的’元数据’，用于描述网页文件的数据比如定义网页的作者、字符集、优化网页在搜索引擎中的显示效果</li></ul><h2 id="HTML-和-CSS"><a href="#HTML-和-CSS" class="headerlink" title="HTML 和 CSS"></a>HTML 和 CSS</h2><p>通过 css 我们可以修改自定义 html 标签的外观，css 可以和 html文件定义在一起，还可以单独放在一个文件里面然后引入。</p><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><p>内联样式是直接把css效果和html标签定义在一起，是一种比较方便的做法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;text-align: center;&quot;</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过<strong>标签的style属性</strong>就能定义标签的css样式，css值则是<strong>键值对</strong>的形式。</p><h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><p>将标签中的css属性从标签中抽出来，<strong>定义在<code>&lt;style&gt;</code>标签中。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">p</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">color</span>:blue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"><span class="hljs-selector-tag">h1</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">    <span class="hljs-attribute">text-align</span>:center;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>抽离出来后通过css选择器选中标签，然后定义它的属性。</p><h3 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h3><p>这是最理想的方式，<strong>方便维护</strong>。将<strong>css属性定义在一个单独的文件</strong>里面，然后通过<code>&lt;link&gt;</code>标签引入就行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;cssfile.css&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>href</code>属性就是css文件的位置。</p><h2 id="HTML和JS"><a href="#HTML和JS" class="headerlink" title="HTML和JS"></a>HTML和JS</h2><p>脚本是HTML的灵魂，通过一对<code>&lt;script&gt;</code>标签就可以定义js文件了。和css一样，脚本文件也推荐定义在一个单独的文件里面， 不过js是指定<code>&lt;script&gt;</code>的<code>src</code>属性来引入外部js文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>本地js<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scr</span>=<span class="hljs-string">&quot;外部js文件.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="HTML布局"><a href="#HTML布局" class="headerlink" title="HTML布局"></a>HTML布局</h2><p>HTML标签有两种类型，一种是块级元素，一种是内联元素。<strong>块级元素会占满整行，然后高度包裹自身。因此块级元素会带有类似换行的效果。</strong>块级元素的典型代表是<code>&lt;div&gt;</code>。</p><p>而<strong>内联元素会紧接着上一个标签元素从左往右排列。</strong>内联元素的代表是<code>&lt;span&gt;</code>标签。</p><h2 id="HTML表单"><a href="#HTML表单" class="headerlink" title="HTML表单"></a>HTML表单</h2><p>表单在网页中用于和用户交互。表单由<code>&lt;form&gt;</code>标签定义。</p><p><code>&lt;form&gt;</code>有两个常用的属性</p><ul><li>action 指定发送表单到哪里，通常是一个链接。</li><li>method 指定发送表单的方式，常见内容有<code>get</code>、<code>post</code>。</li></ul><h3 id="输入框"><a href="#输入框" class="headerlink" title="输入框"></a>输入框</h3><p>使用<code>&lt;input&gt;</code>标签定义一个输入标签，它是一个单标签，一个输入标签有很多类型。 <strong><code>&lt;input&gt;</code>还有一个<code>checked</code>属性，加上这个属性，在提交表单时就会要求改输入标签不为空。</strong></p><p><code>input: &lt;input type=&quot;text&quot; name=&quot;inputtext&quot;&gt;</code></p><ul><li>文本输入框：<input type="text" name="inputtext"></li><li>密码输入框：<input type="password" name="inputtext"></li></ul><p>把<code>&lt;input&gt;</code>标签的<code>type</code>属性定义为<code>text</code>就能生成一个文本输入框。改成<code>password</code>就能生成一个密码输入框，输入后里面的内容将显示为 * 号。</p><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p>按钮同样也是使用<code>&lt;input&gt;</code>标签定义，只要修改下属性就行了。</p><ul><li>单选按钮 <code>&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;</code><br><input type="radio" name="sex" value="male">Male <input type="radio" name="sex" value="female">Female</li><li>多选按钮 <code>&lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Bike&quot;&gt;</code><br>  <input type="checkbox" name="vehicle" value="Bike">Eat<input type="checkbox" name="vehicle" value="Car">Sleep</li><li>提交按钮 <input type="submit" value="Submit"><br>  <code>&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</code></li></ul><p>单选按钮使用<code>radio</code>，一组单选按钮<code>name</code>属性必须一样；多选使用<code>checkbox</code>。点击提交按钮将直接发送标签给指定的连接。</p><h3 id="lable标签与表单"><a href="#lable标签与表单" class="headerlink" title="lable标签与表单"></a>lable标签与表单</h3><p>label标签让它将它自身包裹的值于表单元素关联起来，使用lable标签更有利于指出输入表单的内容。具体表现出来的效果就是，<strong>直接点击文本也能激活输入框。</strong></p><p><label for="t1">带lable的输入框：</label><input id="t1" type="text"><br><code>&lt;label for=&quot;t1&quot;&gt;带lable的输入框：&lt;/label&gt;&lt;input id=&quot;t1&quot; type=&quot;text&quot;&gt;</code></p><p>下面是一个完整的表单代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;demo_form.php&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>  First name: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fname&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  Last name: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lname&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="lt-iframe-gt"><a href="#lt-iframe-gt" class="headerlink" title="&lt;iframe&gt;"></a><code>&lt;iframe&gt;</code></h2><p>使用<code>&lt;iframe&gt;</code>标签可以定义一个指向其它html页面的框架。说简单点就是在html页面内部嵌套另一个html页面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.runoob.com/&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200px&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">height</span>=<span class="hljs-string">&quot;200px&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ifremea&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://anothlink.com&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;ifremea&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>src 指定要加载页面的url</li><li>freameborder 指定边框</li></ul><p>通过指定 <code>a</code> 标签的<code>target</code>属性为<code>&lt;iframe&gt;</code>的<code>name</code>属性，<strong>可以将 <code>a</code> 标签指向的页面加载到指定的<code>&lt;iframe&gt;</code>框架中</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML简介</title>
    <link href="/2021/07/HTML%E7%AE%80%E4%BB%8B/"/>
    <url>/2021/07/HTML%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>HTML是用来描述网页内容的一种语言，<strong>它不是编程语言，而是标记语言，用来描述网页的内容。</strong></p><span id="more"></span><p>HTML使用各种各样的标签来描述其内容，<br>比如使用一对<code>&lt;h1&gt;标题&lt;/h1&gt;</code>标签用来描述中间的字符是标题，<code>&lt;p&gt;&lt;/p&gt;</code>描述中间的内容是一个段落等。</p><p><strong>标签通常都是成对出现的，而且在结束标签前会有一个”&#x2F;“。但也有单标签，比如<code>&lt;img&gt;</code>标签，用于表示图片。</strong></p><h2 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h2><p>一个完整的html页面结构：<br><img src="/images/2021S2/html_structure.jpg" alt="HTML结构"></p><p><code>&lt;head&gt;&lt;/head&gt;</code>中<strong>存放对网页的描述，描述文件的属性、字符集、网页语言等。</strong><br><strong><code>&lt;body&gt;&lt;/body&gt;</code>中则存放网页的内容，我们的工作主要是在这对标签内。</strong></p><h3 id="头文件声明"><a href="#头文件声明" class="headerlink" title="头文件声明"></a>头文件声明</h3><p>在HTML文件的第一行总是有一个<code>&lt;!DOCTYPE html&gt;</code>。因为HTML有各种各样的版本，且不同版本之间对相同的一个标签显示的效果可能有差异，所以需要加上<code>&lt;DOCTYPE&gt;</code>来告诉浏览器本文件的版本，从而<strong>帮助浏览器正确显示内容。</strong></p><h3 id="HTML中的注释"><a href="#HTML中的注释" class="headerlink" title="HTML中的注释"></a>HTML中的注释</h3><p>注释可以让我们对某行代码以我们自己的方式进行描述，同时也不会影响到正常的元素显示。浏览器不会显示我们的注释。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--  --&gt;</span><br><span class="hljs-comment">&lt;!-- 中间的内容为注释 --&gt;</span><br></code></pre></td></tr></table></figure><h3 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h3><p>如果自己写的HTML文件打开后中文显示乱码，这时候先看看<code>&lt;head&gt;</code>标签中有没有加上<code>&lt;meat charset=&quot;utf-8&quot;&gt;</code>，这个代码用来告诉浏览器文件使用的是utf8作为字符集。</p><h3 id="浏览器的作用"><a href="#浏览器的作用" class="headerlink" title="浏览器的作用"></a>浏览器的作用</h3><p>浏览器负责从服务器下载指定的HTML页面，并按照HTML的标签显示内容。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven入门</title>
    <link href="/2021/06/Maven%E5%85%A5%E9%97%A8/"/>
    <url>/2021/06/Maven%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>在实际开发中，我们会不可避免的使用各种各样的 Jar 包。为了避免每次都要手动复制 Jar 包的麻烦，Maven出现了。-d</p><span id="more"></span><p>Maven是一种项目管理工具，官方是这么定义的。简单来说呢 Maven 主要是为了在项目中实现自动导包的功能。当然实际上它不止可以做这些。</p><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><p>在官方的定义中，maven 的项目构建分别是：<strong>清理、编译、打包、测试、报告、打包、安装、部署</strong>。这样理解会有一定抽象。</p><ol><li>清理，就是清理先前的编译结果，为下一次编译做准备。</li><li>编译，主要是把<code>java</code>文件变成<code>class</code>文件，这个工作就和编译器干得差不多。</li><li>测试，对代码进行测试。</li><li>报告，显示测试结果。</li><li>打包，测试通过的项目工件封装成 jar 或者 war 包。</li><li>安装，将打好的包安装到本地仓库中。</li><li>部署，打好的包部署到服务器中。</li></ol><p>简单来说 mavne 的核心功能还是管理 <strong>jar 包，自动测试，和发布（部署）项目</strong>。</p><ul><li><strong>约定大于配置</strong></li></ul><h2 id="Maven安装与使用"><a href="#Maven安装与使用" class="headerlink" title="Maven安装与使用"></a>Maven安装与使用</h2><h3 id="安装Maven"><a href="#安装Maven" class="headerlink" title="安装Maven"></a>安装Maven</h3><ol><li>在<a href="https://maven.apache.org/download.cgi">Apatch 官网</a>下载最新的 Maven 工具。</li><li>解压 Maven 到某个文件夹</li><li>配置 Maven <strong>环境变量</strong><ol><li><code>MAVEN_HOME</code> 环境变量，指向 Mavne 的安装目录</li><li><code>M2_HOME</code> 环境变量，指向 Maven 安装目录下的<code>bin</code>目录。</li><li><code>path</code>变量中添加指向 <code>M2_HOME</code> 变量。</li></ol></li><li>cmd中测试使用 <code>mvn -version</code> 命令测试是否安装成功。</li></ol><h3 id="配置Maven仓库"><a href="#配置Maven仓库" class="headerlink" title="配置Maven仓库"></a>配置Maven仓库</h3><p>上面提到过 Maven 有一个<strong>中心仓库</strong>的概念，这个中心仓库，可以是远程，也可以是在本地，先配置一个本地仓库。我们把本地仓库放到 Maven 安装目录中。</p><ol><li>在 Maven 安装目录下新建一个<code>maven-re</code>文件夹，这个文件夹作为我们的本地仓库</li><li>在 Maven 安装目录下的 <code>conf</code> 里有个<code>settings.xml</code> 文件，在里面加入<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>apache-maven-3.8.1\maven-re<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br></code></pre></td></tr></table></figure>这样我们的本地仓库就算建好了。</li></ol><h4 id="远程仓库镜像"><a href="#远程仓库镜像" class="headerlink" title="远程仓库镜像"></a>远程仓库镜像</h4><p>如果需要，还可以配置一个远程仓库镜像加快下载 Jar 包的速度<br>在上面的<code>settigns.xml</code>文件的<mirrors>标签中加入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>        <br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="约定目录结构"><a href="#约定目录结构" class="headerlink" title="约定目录结构"></a>约定目录结构</h3><p>Maven 中遵循约定大于配置的规定，所以我们的 Maven 项目都需要遵循这样一个目录结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>src<br>    <span class="hljs-regexp">//m</span>ain 放置主程序代码<br>        <span class="hljs-regexp">//</span>java 程序代码<br>        <span class="hljs-regexp">//</span>resource 资源文件<br><br>    <span class="hljs-regexp">//</span>test 放测试文件代码<br>        <span class="hljs-regexp">//</span>java 测试程序代码<br>        <span class="hljs-regexp">//</span>resource 测试资源文件<br>pom.xml Maven的核心配置文件<br></code></pre></td></tr></table></figure><p>Maven 项目启动时会先读取 pom.xml 获取项目信息，然后允许 main 目录下的主程序。</p><h3 id="Maven的使用"><a href="#Maven的使用" class="headerlink" title="Maven的使用"></a>Maven的使用</h3><p>我们先通过命令行来使用Maven</p><ol><li>先按照上面的目录结构建好一个 Maven 项目，并在 java 中随意编写一个 class，并编写一个 pom.xml 文件。</li><li>在项目根目录，也就是 src 同级的目录使用 cmd 命令 <code>mvn compile</code> 构建 maven 项目</li><li>构建结束后，项目根目录会生成一个名为 ‘target’ 的文件夹，它就是 maven 为我们编译好的结果。</li><li>在 target 的子目录 classes 中 执行 java 命令运行类以测试项目。</li></ol><h3 id="Idea-中-Maven-的使用"><a href="#Idea-中-Maven-的使用" class="headerlink" title="Idea 中 Maven 的使用"></a>Idea 中 Maven 的使用</h3><p>Idea中内置了Maven，不过我们前面都自己下好了一个，肯定是用我们自己的Maven。</p><p>我们需要在<code>Idea-&gt;File-&gt;Settings-&gt;Build-&gt;BuildTools-&gt;Maven</code>中，把Maven的<code>home path</code>和<code>local repository</code>改成我们刚刚配置的。</p><h4 id="新建项目测试"><a href="#新建项目测试" class="headerlink" title="新建项目测试"></a>新建项目测试</h4><p>Maven配置完成后，下一步开始新建项目测试，直接新建一个Maven项目，选择<code>maven-archetype-webapp</code>，然后注意选择Maven版本时选择我们刚刚配置好的Maven版本就行了。</p><h4 id="添加-Maven-依赖"><a href="#添加-Maven-依赖" class="headerlink" title="添加 Maven 依赖"></a>添加 Maven 依赖</h4><p>因为要用到servlet，所以我们还需要添加servlet的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- servlet 依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    Jsp 依赖 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置完后，就能直接新建servlet啦。</p><h2 id="Maven核心概念"><a href="#Maven核心概念" class="headerlink" title="Maven核心概念"></a>Maven核心概念</h2><p>Maven有一些核心名词，先了解一下：</p><ul><li>pom ： 项目对象模型，maven 把一个项目当成一个模型使用</li><li>坐标：一个用来表示项目资源位置的字符串</li><li>依赖管理：就是管理各种 jar 包之间的依赖关系</li><li>仓库管理：管理远程仓库或者本地仓库，仓库用来放各种 jar 包</li><li>生命周期：整个项目构建的流程就是一个生命周期</li><li>插件和目标：maven 中使用插件（就是jar）来实现某个功能，一个单独的生命周期过程就是一个目标</li><li>继承：maven 父子项目</li><li>聚合：合并多个小项目</li></ul><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>Maven 通过仓库来进行<strong>依赖管理</strong>，依赖管理是指管理各种 jar 包，这其中有 Maven 用来构建项目的 jar，也有我们项目自己依赖的 jar。</p><p>仓库分为<strong>远程仓库和本地仓库</strong>，构建项目需要 jar 包时，先在本地仓库找，找不到就去远程仓库找。</p><p>远程仓库其实还可以分为，中央仓库，中央仓库镜像，和本地的局域网仓库。</p><h3 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h3><p>在 Maven 中是把一个项目看成一个模型就行配置的，所以对项目的大部分操作都是体现在 pom 文件当中的。我们先来看一个简单的 pom 文件格式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 用来表示 对象模型的版本，现在通常是4.0.0 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.lee.random<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ramdomId<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 定义依赖的作用范围 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 指定 maven 项目的打包文件类型，默认是 jar，还可以是 war、rar、pom等--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span> <br><br>    <span class="hljs-comment">&lt;!-- 指定模型（项目）配置的属性 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义一个全局变量 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">aVersion</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">aVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 指定模型的构建属性，比如修改构建项目插件的一些属性 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependence</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 使用properties中定义的全局变量 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;aVersion&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependence</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependence</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">dependence</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependence</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">dependence</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h4><p>任何一个 Maven 项目都必须要有它自己的坐标，坐标则用来标识项目，有点类似于数据库中的<strong>主键</strong>。</p><p>Maven 项目的坐标由这三个标签组成</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 组 id 一般是公司域名倒写 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.lee.random<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br><span class="hljs-comment">&lt;!-- 项目 id，也就是项目名 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ramdomId<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 版本号，带 SNAPSHOT 表示是开发中版本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 依赖的作用范围，默认是compile</span><br><span class="hljs-comment">     compile 代表整个生命周期这个依赖都存在</span><br><span class="hljs-comment">     test 代表只在测试阶段存在</span><br><span class="hljs-comment">     provided 代表只在编码阶段存在，打包以及之后都不需要这个依赖</span><br><span class="hljs-comment"> --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br></code></pre></td></tr></table></figure><p>另外，坐标在仓库中的体现就是文件夹的目录结构。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>当我们的项目需要使用别的 jar 包时，我们就直接的 pom 中写入依赖项，然后 maven 在构建项目时会自动帮我们去加载 jar 到我们的项目中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这个依赖的格式就和上面讲的 坐标 很像，所以说坐标用来定位一个资源 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.26<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="生命周期、命令"><a href="#生命周期、命令" class="headerlink" title="生命周期、命令"></a>生命周期、命令</h2><p>前面所说的<a href="#%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA">项目构建</a>的几个步骤就是 Maven 项目的生命周期，其中的单独一个步骤，就是一个生命周期。</p><p>前面通过命令完成了项目的构建，当然还有更多的命令，<strong>这些命令都是通过插件完成的，也就是 jar 包</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 清理项目，清理之前的编译结果 --&gt;</span><br>mvn clean <br><span class="hljs-comment">&lt;!-- 编译项目，会生成一个target文件夹作为编译结果 --&gt;</span><br>mvn compile<br><span class="hljs-comment">&lt;!-- 编译测试项目，编译main/java，会生成一个target文件夹作为编译结果 --&gt;</span><br>mvn test-compile<br><span class="hljs-comment">&lt;!-- 运行测试项目，编译test/java，会生成一个surefire文件夹，保存报告 --&gt;</span><br>mvn test<br><span class="hljs-comment">&lt;!-- 打包项目，按照pom文件给项目打包，打包好的文件输出到target文件夹中 --&gt;</span><br>mvn package<br><span class="hljs-comment">&lt;!-- 安装项目，打包本项目，按照坐标把本项目保存到本地仓库中，并使用坐标划分文件夹：groupId/artifactId/version/ *.jar --&gt;</span><br>mvn install<br><span class="hljs-comment">&lt;!-- 部署项目，除了保存到本地仓库外，还会上传到私有网络内的仓库中，并部署到web容器 --&gt;</span><br>mvn deploy<br><br><span class="hljs-comment">&lt;!-- 如果直接执行test命令，maven也会自动执行前面的 clean,compile,test-compile等。其它的命令也同理，会自动从头来一遍。 --&gt;</span><br></code></pre></td></tr></table></figure><h3 id="测试项目"><a href="#测试项目" class="headerlink" title="测试项目"></a>测试项目</h3><p>测试项目会测试类中的每一个方法，方法就是测试的最小单元，<strong>所有又叫单元测试</strong>。我们通过 junit.jar 插件来进行单元测试。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 加入这个依赖来实现单元测试的功能 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>推荐在测试类名和测试方法前都加上<code>Test</code>。 </p><p>测试方法也有定义规则，</p><ol><li>方法是public</li><li>方法无返回值</li><li>方法加上注解@Test</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
      <category>Maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
      <tag>Tool</tag>
      
      <tag>Dependency</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
